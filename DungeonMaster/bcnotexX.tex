\chapter{Úvod}
Originální hra Dungeon Master pochází z dob , kdy její autoři byli značné limitování tehdejším hardwarem i softwarem.
Jedná se především o nedostatek výkonu, paměti a absence vyšších programovacích jazyků.Zejména kvůli poslednímu
bodu je celá původní hra implementována staticky. Z čehož plyne, že s jakýmkoli rozšířením enginu je zapotřebí
upravovat stávající kód. Což dnes již víme, že je značně neefektivní. Datový soubor, který obsahuje data o levelech
originální hry, obsahuje následující prvky. Především obsahuje jednotlivé mapy, kdy jedna mapa odpovídá vždy jedné
hladině a čím vyšší level tím hlouběji se dostáváme. Každá mapa je složena z dlaždic a má danou výšku a šířku.
Celá plocha je vyplněna dlaždicemi různých typů. Je to například zeď, podlaha, teleport, jáma, schody, iluze zdi, 
otevírací zeď, dveře atp. Na každé dlaždici mohou být objekty. Mohou to být věci, které se dají sbírat a nějak 
používat. Dále pak příšery, hráč, dveře, teleport a přepínače, které tvoří základní mechaniky  dungeonu. Pro každé tyto
objekty, je ještě definovaný jejich konkrétní typ. Tzn. může být mnoho druhů přepínačů, příšer, dveří atp.

Jelikož je tato hra velmi známá, existuje již několik klonů, oproti nim se ale tato práce snaží zejména o vyřešení 
problému s rozšiřitelností a udržitelnosti enginu. Z toho důvodu je celý engine naprogramovaný v jazyce c\#, který
obsahuje dostatečné silné koncepty pro dosažení tohoto cíle.

Dalším cílem je samozřejmě to, aby byla reimplementace co nejpodobnější originální hře. Avšak již není kladen důraz
na t, aby obsahovala veškeré detaily. A to protože z předchozího odstave vyplývá, že by mělo být jednoduché dodělat
detaily kdykoliv jindy jako rozšíření. Jelikož se jedná pouze o další rozšíření,  na které by měl být engine připravený.



Z předchozích cílů vyplývají následující podcíle, které je třeba vyřešit. 
\begin{itemize}
\item Samotné rozparsovaní a interpretace dat obsahující herní mapy. 
\item Reprezentace dungeonu jako celku.
\item Reprezentace samotných levelů.
\item Reprezentace dlaždic v jednotlivých levelech.
\item Reprezentace přepínačů 
\item Sestavování herních map a inicializování objektů
\item Renderování a interakce s objekty.
\item Reprezentace herních entit.
\item Uspořádaní entit na dlaždicích
\item Reprezentace vlastností a schopností entit
\item Reprezentace relací mezi entitami
\item Reprezentace těl entit a jejich inventářů
\item Reprezentace věcí objevujících se v dungeonu
\item Reprezentace akcí s věcmi.
\item Reprezentace kouzel.
\end{itemize}
	
\chapter{Related works}

\chapter{Analýza}
Tato kapitola pojednává o postupech a řešeních použitých pro jednotlivé části enginu. Jsou zde popsáný jak slepé a špatné
návrhy, tak návrhy, které se ukázaly jako nejlepší.

\section{Parsování binárních dat}
Aby bylo celé dílo vůbec proveditelné, bylo nutné zajistit, že bude možné rozparsovat data map originální hry. K tomuto účelu
dobře posloužila existující technická dokumentace (viz. \citet{TechnicalDocumentationFontanel05}). Zmíněná dokumentace obsahuje
popis binárního formátu herních map. Není však vždy úplně jasný vztah konkrétních věcí vzhledem k celému projektu. Z toho důvodu
se při interpretaci dat muselo projít mnoho slepých cest metodou pokus omyl. 

I z předchozího důvodu se ukázalo lepší vytvořit samostatnou vrstvu, která data rozparsuje do datových objektů, ke kterým
je přistupováno z vrstev vyšších. Formát herních map obsahuje některá specifika, kvůli kterým, bylo vhodné nad samotnými
rozparsovanými daty provést ještě post-processing. Například se jedná o uložení objektů, na dlaždicích. Každá taková dlaždice
má v původním formátu spojový seznam tzv. objektových identifikátorů. Tyto identifikátory obsahují typ věci, na který odkazují
a potom index do datové struktury daného typu. V rámci post-processingu je v každé dlaždici vytvořen seznam pro konkrétní typ.
Tyto seznamy jsou pak naplněny daty ze spojového seznamu. Tento přístup ulehčí a zpřehlední práci vyšší vrstvě používající tato
data.

Výše popsaná data obsahují pouze popis herních map. Samotné vlastnosti daných objektů, které nejsou ovlivnitelné při návrhu
herních map neobsahují. Tyto data jsou obsažena v dalších binárních souborech. Nicméně tuto práci již odvedlo mnoho jiných a 
jsou například vystavená na webových stránkách v HTML formátu (viz. \cite{HtmlDataFontanel05}). Proto jsem se rozhodl tuto 
práci využít a rozparsovat přímo HTML data do datových objektů. Tato fáze je opět přidána do parsovací vrstvy. K usnadnění 
práce s HTML jsem použil knihovnu \citet{HtmlAgilityPack}. Některé části HTML souborů jsou manuálně upraveny, pro usnadnění
parsování. Z těchto souborů jsem také získal některé textury, například pro věci, příšery, a portréty šampionů. Další potřebné
textury jsou buď z vlastni tvorby nebo získané pomocí extraktoru (\citet{TextureExtractor}). 

Tato vrstva je navíc oddělena do speciálního projektu a to z toho důvodu, že v době její tvorby ještě nebylo rozhodnuto jaký framework
bude použit pro přístup ke grafické kartě.

\section{Použití frameworku pro práci s grafickou kartou}
Celý projekt není nikterak extrémně vázaný na konečně vybranou platformu. Samozřejmě pro použití jiné platformy by bylo 
třeba provést portaci. Ale jelikož použitý rendering je pouze ve fázi proof of concept, neobsahuje žádné pokročilejší akce
s grafickým hardwarem. A je tedy závislý pouze na několika strukturách. Troufám si tedy říct, že případná portace by s dostatkem
času nebyl až takový problém.

I z předchozího důvodu jsem se nakonec rozhodl přistoupit k výběru frameworku, s kterým už některé zkušenosti mám. Jedná se 
tedy o XNA Framework od firmy Microsoft. Nicméně protože tento framework již není firmou nadále podporován a vyvíjen, použil jsem 
konečně jeho klon MonoGame (\citet{MonoGame}). Velkou výhodou je, že framework je multiplatformní. Jeho tvůrci tvrdí, že podporuje platformy
iOS, Android, MacOS, Linux, Windows , OUYA, PS4, PSVita, Xbox One.

\section{Reprezentace dungeonu jako celku}
Dungeon je logicky rozdělen do jednotlivých levelů, o tyto levely se pak stará samotné jádro enginu. Jádro enginu se ve výsledku stará
pouze o načítání levelů a vykreslování správné oblasti dle pozice hráče. Pro načítání levelů se používají buildery, které jsou zároveň
bodem rozšiřitelnosti. Naprogramováním různých builderů je dosaženo toho, že engine dokáže načítat mapy v různých formátech.

Při každé změně pozice hráče se vyhledají viditelné dlaždice. Pokud je některá z těchto dlaždic označená jako spojnice levelů,
engine propojí tyto dlaždice s odpovídajícími dlaždicemi v cílovém levelu. V originální hře jsou takové dlaždice například schody,
teleport nebo jámy. Nicméně je opět na programátorovi, jaké dlaždice tak označí. Viditelné dlaždice jsou potom aktualizované a renderované.

\section{Reprezentace levelů}
Samotné struktury levelů obsahují pouze seznam dlaždic na dané úrovní dungeonu, identifikátor levelu a seznam živých entit. 
Engine vždy pracuje se třemi posledně načtenými levely.

\section{Reprezentace dlaždic} 
V originální hře jsou dlaždice vždy uloženy v nějakém obdélníkovém poli. To znamená, že dlaždice, které nejsou využity pro~chodby
, jsou vždy vyplněny zdmi. Za účelem udělat engine co nejdynamičtější, nerozhodl jsem se ukládat dlaždice
do obdélníkového pole, ale reprezentovat vazby mezi nimi jako obousměrný orientovaný graf. Jednak pro hodně řídké mapy to může
ušetřit nějaké místo. Nicméně důležitějším důvodem bylo, že při takovéto reprezentaci lze jednoduše získat sousedy pouze
ze znalosti konkrétní dlaždice. Kromě toho je takto celý engine obecnější. Například by takto bylo jednoduší rozšířit celý engine
tak, aby nemusely byt jednotlivé dlaždice na mřížce nebo aby mohli mít dlaždice více sousedů. Byla by to sice velký zásah do celého 
enginu, ale mnoho částí by se takto dalo znovu použít nebo jen drobně upravit.

Předchozí rozhodnutí má následující důsledek. Například již nejsou potřeba dlaždice typu zeď.
Což je dost výrazná změna oproti originální hře, kde dekorace, přepínače, věci atp. jsou uložené právě v dlaždicích typu zeď.
Namísto originálního přístupu jsem se rozhodl, že zdi boudu definovány v samotných dlaždicích typu podlaha. Toto rozhodnutí vedlo také
k některým problémům. Například pro vytváření podlahy bylo nutné číst i další dlaždice kolem té právě vytvářené. Zejména je pak nutné 
posílat zprávy původně cílené zdím na odpovídající dlaždice podlahy. Ve výsledku si myslím, že tato reprezentace je vhodnější
například kvůli možnému rozšíření popsaném v předchozím odstavci. Zdá se být také intuitivnější a tedy srozumitelnější reprezentací.

Zdi jsou tedy součástí dlaždic. Nyní přichází otázka, jak tyto zdi tedy reprezentovat. Buď přímo v samotných dlaždicích nebo
zeď udělat jako zvláštní objekt, který je součástí dlaždic. Ze začátku byl v enginu použit první zmiňovaný způsob. Ukazovalo se ale, 
že tato reprezentace není příliš vhodná, protože potom samotná dlaždice řeší věci, které k ní přímo nenáleží.
Nakonec tato reprezentace byla změněna a v enginu bylo použita druha zmiňovaná možnost. Vedlo k ní zejména předělání oddělené grafické 
vrstvy od té logické. Výhoda tohoto přístupu byla kromě samotného oddělení kódu i možnost znovu použití kódu za pomocí dědičnosti. 
Například zeď s nějakým přepínačem může dědit z normální prázdné zdi. Nicméně ukázala se i nevýhoda tohoto přístupu. A to že komunikace směrem 
ze zdi k dlaždici je trochu těžkopádná. Buď by bylo zapotřebí předat zdi referenci na jejich rodičovské dlaždice nebo se museli použít události.
Pokud to bylo v některých případech třeba, přiklonil jsem se k použití událostí.

\section{Přepínače}
\section{Popis funkce a složení}
Základní mechaniky map dungeon Masteru tvoří tzv. přepínače. Jsou to objekty, které lze nějakým způsobem aktivovat. V originální
hře je to možné kliknutím myši na dekoraci přepínače, přesunem na dlaždici s přepínačem nebo aktivací jiným přepínačem. Ve 
skutečnosti se každý přepínač může skládat z několika senzorů, kde poslední z nich určuje dekoraci přepínače. Každý senzor přepínače
obdrží aktivaci a případně provede svoji akci. Každý sensor může provést lokální nebo vzdálenou akci. Pro lokální akce je to 
zarotování sekvencí senzorů přepínače nebo přidání zkušeností hráči. Pro vzdálené akce je to odeslání zprávy, která se skládá ze samotné akce, tj.
deaktivace, aktivace, přehození stavu. A dále obsahuje směr, který může být interpretován jako strana dlaždice typu zdi, která má 
být aktivována. Nebo pro speciální přepínače může určovat jinou akci. Kromě toho obsahuje další vlastnosti jako typ, zda je opakovatelný, zda je 
použitelný pouze jednou, jakou ma dekoraci, doba, po které se provede akce.

Výše popsaný systém přepínačů přináší hned několik problémů:
	Jakým způsobem efektivně a přehledně rozparsovat data senzorů.
	Z technické dokumentace není zcela zřejmé, jak se mají jaké vlastnosti senzorů použit.
	Jak vůbec reprezentovat přepínače.
	Jakým způsobem provádět vzdálené akce.


\subsection{Reprezentace přepínač}
\subsubsection{První reprezentace}
Jako první způsob jsem se rozhodl vždy pro sekvenci senzorů originální hry vytvořit objekt, který měl stejné nebo o něco obecnější vlastnosti dané sekvence.
Ze začátku se totiž zdálo, že jen výjimečně jsou sekvence senzorů větší či složitější. Proto jsem se rozhodl vytvořit v
novém enginu objekty, které mají obecnější vlastnosti pro několik sekvencí. A určitá sekvence senzorů si poté
inicializuje objekt podle svých vlastností. Vlastnosti senzorů jsem určoval podle textového popisu v dokumentaci, která nebyla úplně dostačující. 
I proto čím více přepínačů jsem naimplementoval, tím více ukazovalo problémů. Nakonec jsem dospěl k závěru, že tento způsob reprezentace je nemožný.

\subsubsection{Druha reprezentace}
Jiná varianta se stále spoléhala na typ objektů z předchozího případu. Parsování sekvence senzorů jsem se rozhodl udělat pomocí konečného 
automatu. Tedy tak,  že pro každý objekt existovaly předdefinované sekvence senzorů. A tak se pro každou sekvenci senzorů našel správně 
reprezentující objekt. Později se ale ukázalo, že i malá změna v sekvenci senzorů může generovat podobný objekt. Takže by bylo třeba
spoustu předdefinovaných šablon a jednoduše by mohl nastat případ, že pro některou sekvenci neexistuje žádný objekt.

\subsubsection{Třetí reprezentace}
Nezbylo teď jiné možnosti než se přiblížit více k implementaci podobné originální hře. Za tímto účelem jsem se začal poohlížet po 
po zdrojových kódech originálu. Originální zdrojový kód pravděpodobně nebyl a nebude nikdy publikovaný. Naštěstí  se ale našel člověk,
který celou hru dekompiloval, takže po zkompilování tehdejším kompilátorem výsledná binárka odpovídala té originální (viz. \citet{DMDekompilation}).
Kód to je sice těžko čitelný, ale obsahuje přesný popis, jak které senzory mají fungovat. Vytvořil jsem tedy objekt přepínač, který má v sobě sekvenci senzorů, tak jako
tomu je v originální hře. S využitím zdrojových kód jsem vytvořil odpovídající objektově orientovaný kód v jazyce c\#. Je tedy například možné 
dovytvořit další nové senzory. V bylo toto rozšiřovaní jen značně omezené, jednotlivé type senzorů se odlišovali číselným identifikátorem.
Jelikož jsem ale nechtěl případné rozšiřitele enginu limitovat tímto způsobem tvorby herních mechanik. Je samozřejmě možný, vytvořit jiný přepínač, který se bude
chovat tak, jak si programátor zvolí. Takže případné nové přepínače nemusí vůbec senzory používat. To jak funguje senzor uvnitř je tedy čistě na
programátorovi.

\subsubsection{Reprezentace zprávy přepínače}
Jak již jsem psal,  celý systém přepínačů je závislý na posílání zpráv. V originální hře je cíl odeslané zprávy vázán na souřadnice dlaždice, na kterou 
se má zpráva odeslat. Jelikož jsem se v enginu nechtěl na plno vázat na tyto pevné souřadnice, rozhodl jsem se to i 
zde udělat trošku jinak. Například jsem zmiňoval, že je principiálně možné, aby dlaždice měla více sousedů, u kterých by pak souřadnice
nešli přesně nastavit. Z tohoto důvodu jsem se rozhodl přepínačům při jejich inicializaci předat referenci na jejich cílovou dlaždici. 
To řeší problémy, které jsem popsal v předchozích větách, nicméně přináší pár dalších (viz. inicializace). Jak jsem již zmiňoval,
v originální hře jsou zprávy opět reprezentovány pevnou datovou strukturou. V této části jsem chtěl dát také programátorovi větší svobodu. 
A to tak, aby bylo možné posílat vlastní zprávy alespoň vlastně vytvořeným dlaždicím. Toho je nakonec možné dosáhnout tak, že vlastní dlaždice bude 
poděděna z generické dlaždice, která bere jako typový parameter typ dané zprávy. Zpráva pak musí alespoň dědit ze základní zprávy, která odpovídá
zprávě v původní hře.

\section{Builder map}
Builder map je objekt, který je schopen dodávat levely samotnému enginu. A stojí na něm, aby vytvořil potřebné mapy z dostupných dat.
Vytvoření builderu je samozřejmě opět na programátorovi. Builder by se měl také start o případně kešování, již načtených levelů. 
Tato práce obsahuje pouze builder schopny rozparsovat mapy originální hry.

Jelikož jsem si původně myslel, že některé zdi nebude vůbec nutné parsovat, rozhodl jsem se v prvotních fázích procházet data map
pomocí algoritmu depth first search. Nakonec se ale ukázalo, že i některé nepřístupně části map jsou používané. 
Například pomocí teleportu, nebo vazbami mezi přepínači. Proto jsem později zvolil techniku, že projdu všechny dlaždice od shora dolů. 
A podle nich vytvořím odpovídající objekty v novém enginu.

\section{Inicializace a sestavení herních map a objektů}
V celém projektu jsem se snažil držet paradigmatu defenzivní programovaní. Tedy jde o to nechávat veřejně pouze takové položky, u kterých
je to nezbytně nutné. Na to navazuje problém s inicializací takových tříd. jelikož například přepínače potřebují referenci na cílovou dlaždici, ale zároveň
jsou obsahem dlaždice, je třeba oddělit fázi inicializace dlaždic od inicializace přepínačů. Potom ale nejde přepínače předat do dlaždic,
aniž by to narušovalo cíl držet se defenzivního programovaní. Kromě toho mají konstruktory takových tříd mnoho parametrů. Nejprve jsem 
inicializaci řešil právě těmito konstruktory, ale z předchozích důvodu jsem přišel s tzv. inicializátory.

Inicializátor je datová třída obsahující vlastnosti, které by normálně, byly parametry konstruktoru inicializovaného objektu.
Místo těchto parametrů je do konstruktoru předán inicializátor. Inicializátor má také události vyvolané
při inicializaci a při dokončení inicializace. Třída beroucí inicializátor jako parametr konstruktoru se zaregistruje na tyto události.
Tím pádem není nutná žádná přebytečná položka ve třídě pro inicializátor. události jsou pak volané skrze metodu v inicializátoru.
Inicializátorem inicializovaná třída si z něj nakopíruje parametry a odhlásí událost. Od té chvíle už není možné třídu modifikovat.
Data inicializátoru se tedy mohou postupně naplňovat a po jejich naplnění se inicializace provede zavoláním jejich metody.
S využitím a asynchronních metod, je navíc možné vyvolat inicializaci prvku (např. přepínačů, které potřebují reference na dlaždice) 
již při vytváření dlaždic. Což vede k přehlednějšímu kódu a celkově k inicializaci cyklických struktur, bez porušení našeho
požadavku defenzivního programování.

S využitím dědičnosti inicializátorů je možné nasimulovat volání rutin konstruktorů, tak jak je v c\#  běžné. Na každé úrovní dědičnosti
se využijí některé vlastnosti inicializátoru. Nechť inicializátor B
je potomek inicializátoru A v hiearchii dědičnosti. A nechť C a D jsou třídy, které chceme inicializovat a zároveň D je potomkem C.
A také platí, že konstruktor třídy D bere inicializátor třídy B a konstruktor třídy C bere inicializátor A. potom inicializátor B můžeme
použít pro oba konstruktory tříd C i D. Přičemž na každé úrovni dědičnosti inicializátoru může být zvláštní inicializaci oznamující událost.
Pokud tedy inicializátor volá inicializační události v e správném pořadí, může to nasimulovat pořadí inicializace běžné u konstruktorů.
Při inicializaci dlaždic je právě tento způsob používán.

\section{Renderování a interakce}
Interakcí je myšleno reakce kliku myší na herní objekt. Z počátku si renderovaní řešil každý objekt sám v sobě. Pozicování
těchto objektů bylo z pravidla absolutní. Naopak interakce byla zase řešena pro všechny objekty stejně pomocí bounding boxu.
Obojí se později ukázalo jako špatný přístup. 

Namísto toho vznikla nová vrstva, oddělená od~samotných objektů zajišťující jak renderování tak interakci. Každý objekt
který to vyžaduje má tak vlastní renderer-interactor na míru. Jak takový objekt vypadá uvnitř je zpravidla na programátorovi. 
Nicméně obvyklý přístup je takový, že renderer má referenci na konkrétní renderovaný objekt. Podle jeho zpravidla readonly vlastnosti potom určuje
chování vykreslovaní nebo interakce. Pokud se jedná o renderery pro statické objekty (např. dlaždice), tak se zpravidla pozicování určuje relativně
vůči rodiči. Takže interakční či renderovací funkce dostane jako parametr dosavadní transformační matici.

Celá výhoda tkví v tom, že za takovýchto podmínek je možné renderovací-interakční vrstvu libovolně přepracovat. Oproti originální hře
, je právě v tomto projektu odlišně provedené renderování. Nicméně nic nebraní tomu napsati s vlastní vrstvu, tak aby vpadala jako originál.

\section{Herní entity}
\subsection{Úvod}
V originální hře existují pouze dva typy entit. Jsou to nepřátelské příšery a hráčovi šampioni. Každé tyto entity se mohou lišit 
v závislosti na jejich vlastnostech. Tedy ve hře existuje několik druhů šampionů a několik druhů příšer. V originální hře jsou 
tyto dva světy naprosto oddělené. Já jsem se nicméně rozhodl udělat celou situaci o něco obecnější.

Entitou v tomto enginu může být téměř cokoliv s čím je potřeba nějak interagovat ve smyslu bojů atp. Tedy cokoliv co má nějaké vlastnosti.
Entity si dále definují tzn. uspořádaní na dlaždici. Takže například dveře jsou entita, která má vlastnosti jako zdraví, odolnost atp.
Tento příklad je ukázkovou věcí, která je v originální hře řešena staticky. S využitím entit v těchto případech je možné dosáhnout  větší obecnosti
a tím pádem je se možné vyhnout zbytečně specializovanému a podobnému kódu.

Kromě entit jsou v enginu ještě tzv. živé entity. Což jsou entity s tím rozdílem, že kromě vlastností mají také schopnosti.
Dále mají definovanou pozici dle uspořádaní, relaci vůči ostatním živým entitám(zda jsou přátelští či nepřátelští) a 
konečně části těla a inventáře.

Z hlediska enginu jsou teď oproti originální hře šampioni i příšery na rovnocenné úrovni.

\subsection{Vlastnosti a schopnosti entit}
Cílem nového enginu je opět poskytnout možnost rozšíření vlastností a schopností.
Za následujících podmínek je teď možné na tomto enginu postavit hru, která si sama definuje, jaké vlastnosti a schopnosti, které entity budou mít.
Dále je možné nadefinovat akce, které tyto vlastnosti a schopnosti budou využívat. Tim je dosaženo opět další dynamičnosti enginu.

\subsubsection{Vlastnosti}
V původní hře jsou vlastnosti opět pevně definované. Jsou to například vlastnosti jako zdraví, mana, výdrž, síla atp.
Šampioni a příšery mají většinu vlastnosti odlišných, tím pádem i způsob jejich použití je odlišný. Jak jsme si ale řekli v předchozí sekci,
tak příšery i šampioni v novém enginu jsou nyní na stejné úrovni. Zároveň některé entity některé vlastnosti mít nemusí a tím pádem jsou u nich 
tyto vlastnosti v základní hodnotě. Z toho důvodu jsem se rozhodl nechat seznam vlastnosti na každé entitě zvlášť zcela dynamicky.
Pokud daná entita některou vlastnost nemá, vrátí svoji základní hodnotu. Potom při konání některé akce ovlivňující vlastnosti dané entity se
 akce sama rozhodne, které vlastnosti nějakým způsobem použije. Například pokud provádíme akci útok magickou ohnivou koulí a entita nemá žádné vlastnosti 
 odolnost proti magii či odolnost proti ohni. Jsou tyto vlastnosti v základním stavu, čili nijak neovlivní damage způsobené touto akcí.

 \subsubsection{Schopnosti}
 Schopnosti jsou stejně jako vlastnosti v originální hře pevně definovány. I v tomto bodě se nový engine snaží o větší
 dynamičnost. Opět ne všechny entity musí mít všechny schopnosti. Pokud určitou schopnost entita nemá, vrátí se její hodnota s levelem nula.
 Podle schopností se určuje, zda je entita danou akci schopna provést. Tedy každá akce má definovaný minimální levely pro sadu schopností.
 Pokud pak levely vyhovují, může být daná akce provedena.

 V originální hře jsou dva typy schopností. Jsou to základní schopnosti a skryté schopnosti. Pokud některá akce vylepšuje schopnost skrytou
 rozdělí se získané zkušenosti mezi obě schopnosti. Tento koncept schopností není v enginu vyžadován. Je možné si udělat jednoúrovňové 
 schopnosti nebo klidně několika úrovňové schopnosti. Vše záleží na tom jaké chování programátor daným schopnostem naprogramuje. 

 \subsection{Relace mezi entitami}
 Další funkcí kterou oproti originálu engine umožňuje je definovat pro entity jejich nepřátelé. Každá živá entita má token identifikující
 skupinu. Entity v této skupině jsou mezi sebou přátelské. Každá entita si může nadefinovat svoje nepřátelské tokeny.
 Podle vzdoru originálu jsou v této konkrétní hře pouze dva relační tokeny. Jeden pro šampiony a druhý pro příšery. Nicméně
 celý tento system je navržen právě pro navržení obecnějších vztahů mezi entitami. Pro případné použití tohoto enginu pro jiné účely,
 než je originální hra.

\subsection{Tělo a inventáře}
Každá živá entita má definované její části těla. Oproti originálu, kde se řeší pouze části těla šampionů,
zde je možné definovat tělo pro každou entitu. Je tak možné pracovat s částmi těla entit, které nemají humanoidní formu.
Některé části těla se dají použít jako úložiště věcí. Věci potom mají nadefinováno s jakým typem úložiště jsou kompatibilní.
Tato reprezentace dává dobrý smysl. Například pokud máme lidskou část těla nohy. A medvědí část těla nohy. Tak lidské
kalhoty by měli jít nasadit pouze na lidské nohy, nikoliv medvědí. Naopak medvědí chrániče na nohy půjdou dát pouze na
nohy medvědí. Takto pokročilejší věci v originální hře nejsou použity, věci tam mohou sbírat pouze šampioni. Nicméně
pro případné rozšiřitele je principiálně možné navrhnout hru, v které se tyto techniky budou používat.

Kromě částí těla jsou zde ještě definovány další externí úložiště, které slouží jako hlavní úložný prostor. O velikosti
a typu těchto úložišť opět rozhoduje tvůrce konkretních entit. Nicméně stejně tak jako v originální hře, i tato instance má neimplementované 
úložiště pouze pro šampiony. Mezi taktové úložiště patří například batoh, kapsa, bedna, toulec atp.

\section{Věci}
Tato sekce pojednává o věcech, které se objevují v mapách hry Dungeon Master. Myšleno věci, které jdou sebrat ze země,
vložit do ruky hráče či šampiona, vložit do inventáře či úložiště kdekoliv v dungeonu(např. do výklenků). Takovéto věci 
mohou zejména definovat akce, které s nimi lze provádět. Věci v originální hře se děli do několika skupin tj. zbraně,
zbroje, lektvary, truhly a další. Každá věc může mít několik akcí a je na uživateli enginu, jakou akci dané věci přiřadí.

V originální hře má každá věc unikátní číselný identifikátor, který používá pro jednoznačnou identifikaci typu předmětu.
Nikoliv typu jako typ proměnné, ale jako například jeden konkrétní typ zbraně. Tyto identifikátory jsou používány především
u různých druhů klíčů, ale není to podmínkou. Identifikátory jsou obecně používané sensory, například tak, že konkrétní senzor
se aktivuje pouze pokud má hráč v ruce věc s určitým identifikátorem. Není tedy pravda, že každá instance například klíče má
rozdílný identifikátor, naopak, všechny instance klíče stejného druhu, mají stejný identifikátor.

Z počátku jsem pro stanovení identifikátoru zvolil stejnou strategii jako tvůrci originální hry, ale celou dobu se mi 
to zdálo jako dosti dřevní řešení. Tento problém nakonec vyřešil problém jiný a to jakým způsobem přesně reprezentovat věci, aby neměli zbytečně
položky uložené několikrát a aby se dali snadno vytvářet. Ze začátku měli všechny věci uložené 
všechny jejich vlastnosti u sebe. Bylo to tak i s položkami, které byly vždy pro instanci jednoho typu stejné. Ta jsem se
tyto položky rozhodl delegovat do zvláštních tříd, odpovídající jednotlivým identifikátorům. Reference těchto tříd
tedy není slouží jako identifikátory. Samotné instance věci potom obsahují právě reference na tyto třídy.

Navíc třídy popsané v předchozím odstavci slouží jako továrny na věci jejich typu jakožto identifikátoru. Se znalostmi továrny lze buď
vytvořit věc se základními hodnotami jejich vlastností. A nebo se znalostmi konkrétního type(myšleno jazykového ) továrny, lze předáním inicializátoru vytvořit novou věc
s hodnotami dle inicializátoru. Každá továrna má také vlastnosti jako, hmotnost, jméno, akce, které lze s věcmi provádět, a definice míst v inventáři
, kam lze věc uložit. Specializované type, myšleno jako zbraně, lektvary, atp. pak mají některé další vlastnosti.

\section{Akce}

\section{Kouzla}

\chapter{Programátorská dokumentace}
Následující sekce této kapitoly jsou určeny především pro lidi, kteří chtějí porozumět více celému enginu. Především
však dobře poslouží lidem, kteří by tento engine chtěli použít pro svoji hru nebo by chtěli jen rozšířit některé části
tohoto enginu Dungeon Masteru.

\section{Jádro enginu}
Jádro enginu tvoří třída \ccc{DungeonBase}, jak již bylo řečeno, stará se zejména renderování, aktualizování herních objektů,
inicializaci hráče, načítání a propojování herních map. Pokud má čtenář zájem o úpravu některých z těchto věcí, je tu správně.

\subsection{Renderovaní}
Tato sekce slouží pro čtenáře, kteří mají zájem o reimplementaci následujících věcí:

\begin{itemize}
\item Způsob výběru dlaždic, které se mají používat pro aktualizaci a rendering.
\item Pořadí v jakém se jednotlivé dlaždice renderují.
\item Použití osvětlení a celkově nastavení grafického zařízení.
\item Dosah viditelnosti
\item atp.
\end{itemize}

\subsubsection{Výběr a vykreslování použitých dlaždic}
V základní verzi vždy existuje kolekce právě používaných dlaždic. Tato kolekce se znovu naplní vždy, když hráč změní
pozici. dlaždice se zde vyhledávají algoritmem breath first search.

Vlastní algoritmus výběru dlaždic je možný přidat poděděním třídy \ccc{DungeonBase} a overridnutím  metody \ccc{UpdateVisibleTiles}. 
Metoda uloží do proměnné \ccc{currentVisibleTiles} vybraný seznam dlaždic. Tato proměnná je pak využívána v metodě \ccc{Draw}, kde se
ale renderují v opačném pořadí kvůli průhlednosti.


\subsubsection{Nastavení grafického zařízení}
Nastavení osvětlení a celkově efektu, textury a batcheru pro vykreslovaní minimapy, se provádí v metodě \ccc{InitializeGraphics}.
Jejím overridnutím je možné provést modifikace. Pokud nehodláte upravovat všechny popsané věci, je doporučené zavolat nejprve funkci rodiče
která data zinicializuje na základní hodnotu. Samotná minimapa se vykresluje funkcí \ccc{DrawMiniMap}, která se volá klasicky ve funkci 
\ccc{Draw}. Overridnutím této funkce je tedy možné například minimapu úplně odstranit, tak jako to je v originální hře. V této sekci je ještě
možná dobré zmínit proměnou \ccc{FogHorizont}, která je v základu používaná jednak jako maximální vzdálenost, po kterou jsou dlaždice hledány, a za druhé slouží v efektu jako 
hodnota FogHorizontu.

\subsection{Inicializace hráče}
O abstrakci různých způsobů načítaní levelů se stará interface \ccc{IDungeonBuilder}. Instanci implementace tohoto
rozhraní je nutné předa Dungeonu v konstruktoru. V základu se nové mapy načítají v momentu, kdy některá ze zobrazených
dlaždic je dlaždice navazující na další level. Takové dlaždice jsou právě dlaždice implementující  rozhraní  \ccc{ILevelConnector}.
Poslední tři levely získané skrze \ccc{IDungeonBuilder} jsou uložené v kolekci \ccc{ActiveLevels}. Pokud je nutné změnit 
strategii načítání levelů, je třeba overridovat metody \ccc{SetupLevelConnectors} popř. \ccc{ConnectLevels}. Pro změnu 
strategie ukládání a mazání aktivních levelů, je třeba podědit třídu \ccc{LevelCollection}. Kterou je pak nutno nastavit
do vlastnosti \ccc{ActiveLevels}. 

Následující sekce popisují jaké objekty lze jakým způsobem rozšířit či upravit. O tom jak takové nové objekty potom používat
pojednává pozdější sekce.

\section{Rozšiřitelnost dlaždic}
\subsection{Popis dlaždic}
Nejobecnější strukturu dlaždice definuje interface \ccc{ITile}. Dlaždice tedy musí obsahovat pozici vzhledem
k~mřížce dlaždic a potom level, ve kterém se nachází. Tyto vlastnosti používají příšery nebo hráč k~určení
své pozice. Dále obsahuje vlastnosti sloužící k rozhodovaní pohybu entit, věcí a orientaci příšer. Další částí
je již zmiňovaný \ccc{LayoutManager}, který slouží k rozdělení prostoru mezi entitami na dlaždici. Podle něj se 
příšera či hráč rozhoduje, zda může na danou dlaždici vstoupit a obsadit, tak část jejího prostoru. Má také definované
soused, podle kterých se zase entity rozhodují při pohybu mezi dlaždicemi. Další část API slouží k modifikaci stavu dlaždice.
Stav jde buď přímo nastavit pomocí volaní odpovídajících funkcí nebo předáním zprávy. Poslední
část obsahuje metody a události pro vstup a odchod věcí z dlaždice. O volání těchto  funkcí se musí starat samy objekty,
které chtějí vstoupit či odejít. Takové objekty jsou poté skrze dlaždici aktualizovány, pokud implementují rozhraní
\ccc{IUpdateable}. To však již musí zařizovat jednotlivé implementace dlaždic, o niž bude řeč v další sekci.

\subsection{Inicializace dlaždic}
Jak již bylo zmíněno v analýze, k inicializaci dlaždic jsou použity tzv. inicializátory. Inicializátor
obsahuje vlastností, které by normálně byly předány jako parametry v konstruktoru. Ovšem v moment předávaní
inicializátoru do konstruktoru, inicializátor ještě nemusí být plný. Namísto toho má události \ccc{Initializing}
resp. \ccc{Initialized}, které jsou vyvolány při resp. po inicializaci. Na tuto událost je třeba zaregistrovat
inicializační funkci, která zkopíruje data z inicializátoru do samotného objektu. Pro každou úroveň hierarchie
dědičnosti jsou určeny zvláštní vlastnosti a zvláštní inicializační události. Rodičovské události  inicializátoru jsou vždy
po zdědění rodičovského inicializátory zakryty novými inicializačními událostmi pro danou proveň dědičnosti.
Tento způsob je použit pouze pro inicializaci dlaždic. Pro jiné objekty, může inicializátor sloužit pouze jako 
objekt udržující parametry. Parametry, které jsou hned v konstruktoru inicializované. To vše záleží na konvice kterou si
programátor zvolí.

\subsection{Implementace dlaždic}
O částečnou implementaci rozhraní \ccc{ITile} se stará třída \ccc{Tile}. Definuje základní layout manager,
nicméně je ho popřípadě možné overridovat vlastní implementaci. Zejména se pak ale stará o inicializaci 
pozic na mřížce, levelu a sousedů skrze \ccc{TileInicializator}. Dále abstraktně deklaruje vlastnost
\ccc{SubItems}, na jejichž objektech, které implementují \ccc{IUpdateable} volá metodu \ccc{Update} skrze
metodu \ccc{Update} na dlaždici. Abstraktně deklaruje také vlastnosti \ccc{Sides}, kde těmto stranám přeposílá 
případné zprávy, které přišli na tuto dlaždici skrze metodu \ccc{AcceptMessageBase}. Dále implementuje
také funkce pro vstup/odchod objektů tím, že vyvolá odpovídající události na dlaždici. Pokud tedy chcete
volání těchto událostí zachovat, je při případném overridování metod nutné zavolat implementaci rodiče. Všechny
předchozí popsané funkce je možné overridovat v potomkovi a tak přizpůsobit prováděné akce.

Přímý generický potomek \ccc{Tile\textlangle TMessage\textrangle} poskytuje již zmiňovanou možnost přijímat
v potomcích vlastní zprávy. Poděděním tohoto typu, specifikováním typu zprávy v typovém parametru a následnou implementací metody 
\ccc{AcceptMessage} lze definovat rutinu při příjmu zprávy. Tato třída overriduje a zároveň uzavírá metodu rodič \ccc{AcceptMessageBase},
která deleguje zprávy typu \ccc{TMessage} do metody \ccc{AcceptMessage}. Naopak základní implementace metody \ccc{AcceptMessage}
je zavolání právě rodičovské implementace \ccc{AcceptMessageBase}. Takže při případném overridování této funkce
stojí za zamyšlení, zda-li  je třeba volat implementaci rodiče či nikoliv. Všechny dlaždice, které dědí ze třídy
popsané v tomto odstavci vytváří potomky dva. Jednoho pro případně rozšiřitele, která ponechává 
typový parametr.A druhá, která definuje typový parametr na obecný typ \ccc{Message}. Ještě stojí z zmínku,
že každá zpráva musí dědit právě ze třídy \ccc{Message}.

\subsubsection{Dlaždice podlaha}
Za zmínku ještě stojí přímý potomek třídy \ccc{FloorTile\textlangle TMessage\textrangle} a 
to \ccc{FloorTile\textlangle TMessage\textrangle}.  Tato třída se stará jak o interakce, tak rendering
zdi a podlahy. Stará se tady například o možnost pokládaní věcí na zem, či u zdí do případných výklenků. 
Dále se stará  o zobrazování a aktivování případných přepínačů. Z toho důvodu, pokud se chystáte
vytvářet nějakou novou dlaždici, je dobré se zamyslet, jestli  nevyužít již tuto implementaci. Nicméně nic
nebrání tomu podědit přímo z \ccc{Tile\textlangle TMessage\textrangle}, pokud by tato implementace z
nějakého důvodu nevyhovovala. Při drobných úpravách je zase možné třídě podstrčit pozměněné-poděděné implementace 
jejich stran, ať už zdí nebo podlahy. Třída deleguje veškeré akce vstupu/odchodu do samotné podlahy
typu \ccc{FloorSide}. Stejně tak implementace kolekce  \ccc{SubItems} se deleguje na podlahu.

\subsubsection{Další dlaždice}
Další dlaždice již převážně využívají dědičností právě již zmíněnou předchozí podlahu. Výjimkou jsou například schody.
Schody jsou příkladem  dlaždice, který implementuje rozhraní  \ccc{ILevelConnector},  které požaduje implementaci 
následujících vlastností
\begin{itemize}
\item cílový level
\item pozice cílové dlaždice v cílovém levelu
\end{itemize}

Jak už bylo zmíněno engine potom při načtení levelu nastaví poslední položku tohoto interface 
\ccc{NextLevelEnter} na odpovídající dlaždici. A je už na samotné dlaždici, aby při změně této vlastnosti udělala 
potřebné akce. U schodů je to například nastavení sousedů vedoucích do dalšího levelu. Právě zde se například hodí 
overridování vlastnosti \ccc{Neighbors} vlastní třídou starající se o sousedy. Tato možnost je použita ještě u jámy,
kvůli propadu do nižšího levelu. Rozhraní spojující levely je pak ještě u teleportu, kde při vstupu na teleportační
dlaždici a splnění požadavku teleportu se tento objekt teleportuje na jinou dlaždici. Za zmínku ještě stojí existence
rozhraní \ccc{IHasEntity}, které obsahuje vlastnost typu entity. Implementuje ho například dlaždice typu dveře,
která vrací jako entity dveře. Tímto způsobe lze pak například útokem dveře rozbít, protože jsou definované jako 
entita s vlastností zdraví, odolnost atp. Nikde jinde v enginu toto využito není, tím více prostoru mají případní
rozšiřité.

\subsection{Strany dlaždic}
Jak již bylo naznačeno v předchozích sekcích, dlaždice mohou mít strany. To mohou být ať už zdi, tak i podlaha nebo strop.
Každou tuto stranu reprezentuje samostatný objekt, který má samostatný renderer-interactor. Poděděním z těchto hotových tříd
si lze tedy ušetřit nějakou práci. Není to však nutnost, je možné si pro své dlaždice implementovat vlastní
strany implementací rozhraní \ccc{ITileSide}. Toto rozhraní vyžaduje pouze položku pro renderer a z kompatibilních důvodů
pro starou verzi požaduje, aby byla schopna přijímat zprávy \ccc{Message}.

\subsubsection{Jednotlivé implementace}
Třída \ccc{TileSide} slouží jako rodič všech zdí implementovaných ve hře. Nereaguje nijak na interakci
hráče a její renderer pouze renderuje zdi  texturu na správné místo, popř. dekoraci.

Jejím přímým potomkem je třída \ccc{ActuatorTileRenderer},ta navíc obsahuje přepínač a její renderer se navíc
stará o jeho vykreslování a interakci.

Dalším potomkem je třída \ccc{TextTileSide}, jejíž renderer navíc zobrazuje na zdi text, v závislosti na tom,
zda-li je viditelný. Viditelnost textu lze změnit zasláním zprávy s odpovídajícími informacemi této straně.

Předposlední a nejsložitější stranou je třída  \ccc{FloorTileSide}.  Tato strana obsahuje čtyři úložiště na věci,
kam může uživatel pokládat věci. Je to jedno z míst, kde je potřeba komunikovat s rodičovskou dlaždicí, k tomu
slouží událost \ccc{SubItemsChanged}, která se vyvolá vždy, když byla nějaká věc odebrána nebo přidána.
Pomocí enumerátoru tohoto objektu je potom možné vyenumerovat obsažené věci. Věci lze pak na podlahu přidávat dvěma 
způsoby, jednak přímo z ruky hráče pomocí renderer-interactoru do úložného prostoru na podlaze. Toto
přidání opět pomocí události informuje přes podlahu rodičovskou dlaždici. Další způsob je zavolání metody 
\ccc{OnObjectEnter} resp. \ccc{OnObjectLeft},  které také vyvolají notifikační událost o změně a přidají objekt do nějakého prostoru.
Tento způsob je použit například u teleportu, kde se vědci přidávají do dané dlaždice voláním metody \ccc{OnObjectEnter}.
Tato metoda pak volá odpovídající metodu podlahy. Poslední stranou je  třída \ccc{ActuatorFloorTileSide}, která pouze navíc přidává 
nášlapný přepínač.

\section{Renderery}
Jelikož každá dlaždice a každé strany dlaždic mají renderery, je jím čas věnovat tuto sekci. Všechny tyto objekty
a mnoho dalších k tomuto účelu implementují rozhraní \ccc{IRenderable}, které pouze vyžaduje  položku typu \ccc{IRenderer}. 
Stěžejní funkce tohoto rozhraní jsou funkce \ccc{Render} a \ccc{Interact}. 

Nejdůležitější z parametrů těchto funkcí je dosavadní transformace. Tj. obsahuje složeninu transformací složenou z jednotlivých
transformací na cestě z kořene stromu reprezentující závislosti renderer na sobě. Takže například kořen strumu bude renderer
dlaždice, jeho syn bude strana dlaždice, její syn bude výklenek ve zdi a její syn bude věc ve
výklenku(list). Při takovéto reprezentaci se pak musí všechny renderované objekty posunout či jinak transformovat vůči jejich rodiči.
Tzn. každý renderer si musí zvolit pozicovací konvenci, kterou pak musí závislé renderery dodržovat. Tento způsob renderování je požíván u statických objektu jako
jsou dlaždice, zdi, výklenky a podobně. Pro pohybující objekty je používaná absolutní pozice a renderery
těchto objektů transformují objekty přímo na jejich pozici. Volba mezi těmito dvěma případy je na programátorovi.

Renderery jsou vždy dělány na míru objektu, který mají renderovat. Tzn. často se renderer v konstruktoru 
inicializuje instancí s konkretním typem. Třída této instance pak má zpravidla readonly vlastnosti,
podle kterých renderer určuje, co má vykreslovat. Jelikož implementovaná grafická vrstva je pouze ve formě proof of concept,
je co nejjednodušší a neobsahuje například animace. Nicméně ze zde popsané povahy renderer je jasné, že 
toho může být dosaženo vytvořením událostí na renderovaných objektech, které si renderer zaregistruje.
Dovedu si představit, že by šla s takovýmto návrhem velmi jednoduše udělat grafická vrstva, která bude
velmi pěkná, bude mít kvalitní šD modely animace. Zabralo by to jen spoustu času a byla by k tom u potřeba horda grafiků.

Při podědění nějakého rendereru je třeba zjistit dosavadní transformaci, která je normálně vypočítána v rodiči.
K tomuto záměru slouží funkce \ccc{GetCurrentTransformation}, která bere jako parametr dosavadní transformaci.
Poděděním jež existujícího rendereru lze ušetřit mnoho práce a opakujícího se kódu. Proto je takový přístup v této implementaci často použit.
Funkce popsané na začátku sekce jsou samozřejmě virtuální a jdou overridovat,
obsahují taky jeden parametr typu \ccc{object} pro případné předávaní dodatečných dat mezi renderery. Tohoto parametru není nikde v této implementaci využito.

Jelikož renderery zásadně mění vzhled a pozici všech věcí, je nutné tuto vrstvu propojit i s interakcí.
Interakční funkce má skrze parametr typu \ccc{ILeader}  přístup k položce interactor, která je typu \ccc{object}.
Daný renderer musí vědět, pro jaký typ interactoru je a na ten si ho musí vhodně přetypovat. V této implementaci je použit paprsek (\ccc{Ray}). 
Celý tento koncept interactoru by šel sice udělat genericky, ale prolínal by se celou strukturou rendererů a z toho
důvodu jsem se rozhodl v tomto místě ustoupit. A udělat situaci jednoduší na úkor kontroly za překladu.


\section{Přepínače}
Jak již bylo řečeno, přepínače se skládají z jednotlivých senzorů. Senzory pak mohou provádět následující akce:

\begin{itemize}
\item změna stavu  dlaždice
\item proházení senzorů přepínače
\item přidání zkušeností hráči
\end{itemize}

Senzory mohou být aktivovány:

\begin{itemize}
\item Kliknutím na dekoraci senzoru, pokud je senzor na zdi a je to poslední senzor přepínače.
\item Zprávou od vyslanou jiným senzorem.
\end{itemize}
Tento typ přepínačů odpovídá přepínačům v původní hře.

Dále engine povoluje nové přepínače, který nemusí používat senzory. Je tedy čistě na programátorovi, jakým 
způsobem se bude přepínač aktivovat. 

\section{Implementace přepínačů se senzory}
Za přepínačem stojí navenek interface \ccc{IActuatorX}. Toto rozhraní pouze vyžaduje API pro příjem 
zpráv typu  \ccc{Message} pro dodržení kompatibility s původní hrou. Jelikož ostatní aktivace záleží
na typu přepínače. Protože například nášlapný přepínač se aktivuje jiným způsobem než přepínač na zdi.

Rodiče všech přepínačů kompatibilních originální hře tvoří třída \ccc{Actuator}. Tato třída poskytuje
pouze společnou rutinu pro zarotování senzory přepínače. Lze vyvolat pouze z potomků. Zda-li se mají
senzory zarotovat určuje dle vlastnosti  \ccc{Rotate}, která se poté nastaví na false. Tato funkce se
volá z potomků pokud proběhl pokus o aktivaci nějakého senzoru.

Prvním potomkem předchozí třídy je třída \ccc{FloorActuator}, která může obsahovat pouze senzory určené
na podlahu. Pokus o její aktivaci se provádí funkcí \ccc{Trigger}. Jako první parametr se jí předává objekt,
který vstupuje/odchází z dlaždice. Potom seznam všech objektů na dlaždici a naposled informace zda objekt
vstupuje či vystupuje. Pro přepínač je vytvořena speciální podlaha \ccc{ActuatorFloorSide}, která se stará 
o volání zmíněné funkce.
