\chapter{Vývojová dokumentace}
Celá práce je rozdělena do dvou projektů Visual Studia, pro jejichž otevření je zapotřebí mít nainstalované MonoGame SDK 3.4.
První z nich je \ccc{DungeonMasterParser}, 
který zajišťuje rozparsování herních dat \vref{level-parsing}. Celý tento projekt se skládá z~datových 
tříd odpovídajících formátu souboru \ccc{DUNGEON.DAT} resp. \ccc{GRAPHICS.DAT} (viz sekce \ref{dungeon-objects} resp. \ref{dungeon-properties}),
které pak sestaví dohromady třída \ccc{DungeonParser} za vzniku objektu třídy \ccc{DungeonData}.
Při vytváření instance třídy \ccc{DungeonData} se provede načtení dat odpovídající souboru \ccc{DUNGEON.DAT}.
Kvůli tomu tento projekt referencuje knihovnu HTML Agility Pack \cite{HtmlAgilityPack}.

Druhý projekt \ccc{DungeonMasterEngine} obsahuje už samotný engine, kterému se bude hlavně věnovat tato kapitola.
Projekt s enginem pak referencuje projekt \ccc{DungeonMasterParser} a framework MonoGame \cite{MonoGame}.
Data týkající se herních úrovní jsou ve složce \ccc{/Data} a data jako textury, fonty nebo modely jsou ve složce
\ccc{/Content}, jak je tomu u MonoGame zvykem.  
Oba projekty se pak snaží dodržovat následující konvence:

\begin{itemize}
\item Každá třída nebo rozhraní jsou ve zvláštním souboru korespondujícím s jejich názvy. 
\item Skupiny tříd, které patří logicky k sobě, se separují do zvláštních složek.
\item Jednotlivé složky odpovídají jmenným prostorům.
\item Názvy rozhraní začínají písmenem \ccc{I}.
\item Třídy rozšiřující abstraktní třídy mají část jejich názvu.
\item K abstraktním třídám většinou existuje odpovídající rozhraní se stejnými položkami.
\end{itemize}

Následující sekce této kapitoly popisuje třídy reprezentující jednotlivé části enginu a vztahy mezi nimi.

\section{Jádro enginu -- \ccc{DungeonBase}}\label{engine-core-section}

Jádro enginu reprezentuje třída \ccc{DungeonBase} a skládá ze tří důležitých komponent, které do něj lze předat při jeho vytváření. 
Za těmito komponentami stojí následující rozhraní:

\begin{itemize}
\item \ccc{ILeader} -- reprezentuje hráče a jeho skupinu, kterou lze skrze něj ovládat.
\item \ccc{IFactories} -- obsahuje factories pro tvorbu předmětů, nepřátelských entit, kouzel, akcí a definuje úrovně osvětlení.
\item \ccc{IDungeonBuilder} -- vytváří pro engine herní úrovně.
\end{itemize}


Pro reimplementaci hry Dungeon Master jsou použity následující třídy \ccc{LegacyLeader},
\ccc{LegacyFactories}, \ccc{LegacyMapBuilder}. Konkrétní typy implementací rozhraní
\ccc{ILeader} a \ccc{IDungeonBase} lze předat jádru jako typové parametry.
Případný front end potom může skrze instanci jádra pracovat přímo s konkrétními typy \cc{frontend-core}. Tento projekt
neobsahuje žádné uživatelské rozhraní, namísto něho je pro udávání některých příkazů použita konzole \ccc{GameConsole}.

Jádro lze pak nalézt ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Tiles}.

\imgx{frontend-core}{Ilustrace komunikace frondendu s jádrem enginu. }


\subsection{Asynchronní funkce}\label{async-engine}

Samotné jádro enginu je vytvořeno a aktualizováno ze třídy \ccc{Engine}, která je potomkem třídy \ccc{Game} zajišťující herní smyčku.
V řadě částí enginu se využívají asynchronní funkce ke zjednodušení implementace. Důležité je 
poznamenat, že tyto funkce předpokládají, že budou vykonávané v jednom vlákně -- jinak může velmi jednoduše dojít k race condition.
Z tohoto důvodu je nutné přepnout chování asynchronních funkcí tak, aby se prováděly v jednom vlákně. To lze udělat nastavením 
vhodného synchronizačního kontextu v hlavním vláknu skrze funkci \ccc{SynchronizationContext.SetSynchronizationContext}. 
Tato funkce má jako parametr instanci třídy \ccc{SynchronizationContext}. Správnou implementaci synchronizačního kontextu 
-- tak, aby se asynchronní funkce prováděly v jednom vlákně -- zajišťuje třída \ccc{GameSynchronizationContext}. Tento synchronizační
kontext je nastaven v konstruktoru třídy \ccc{Engine} za předání fronty, do které budou vkládány asynchronní požadavky.
Tato fronta je poté v každém cyklu herní smyčky ve funkci \ccc{Engine.Update} vyprázdněna a každá její funkce je provedena.
Asynchronní funkce implementované v enginu se vždy provádějí ve vlákně herní smyčky. Nicméně při awaitování nějaké 
asynchronní funkce z jiných zdrojů, například \ccc{Task.Delay}, je možné, že se tato funkce provádí v jiném vlákně. Z tohoto 
důvodu je nutné při vkládání a odebírání funkcí z fronty, provádět synchronizaci pomocí zámků.
Jelikož v každém volání této funkce je vyprázdněna celá fronta asynchronních funkcí, je třeba dávat pozor na její přehlcení,
které může v konečném důsledku vést až k neresponzivnosti aplikace.

Následující příklad ukazuje použití asynchronní funkce, která odesílá zprávu dlaždici.
Odeslání zprávy je přitom provedeno až po uplynutí doby \ccc{TimeDelay}.

\begin{code}
async void SendMessageAsync(Message message)
{
   await Task.Delay(TimeDelay);  
   // zpráva je odeslána až po uplynutí doby TimeDelay
   TargetTile.AcceptMessageBase(message);
}
\end{code}

Další příklady využití asynchronních funkcí v enginu bude v následujících sekcích:
\begin{enumerate}
\item sekce \vref{level-builder} -- inicializace cyklických struktur,
\item sekce \vref{xyz} -- umělá inteligence nepřátelský entit,
\item sekce \vref{game-console} -- čekání na vstup do konzole. 
\end{enumerate}


\subsection{Správa herních úrovní a dlaždic}\label{engine-level-management}
Při inicializaci jádra je na objektu hráče zaregistrována událost \ccc{ILeader.LocationChanged}, která
je vyvolána po přesunu hráče na novou dlaždici. Zaregistrování resp. odregistrování události se provede po
přiřazení hodnoty do vlastnosti \ccc{Leader}. V obsluze této události se pak provede aktualizace
viditelných dlaždic pomocí funkce \ccc{UpdateVisibleTiles} \cc{core-tileUpdate}. K nalezení viditelných dlaždic tato funkce používá
třídu \ccc{RendererSearcher}, která je potomkem třídy \ccc{BreathFirstSearch}. Nalezené dlaždice se
uloží do protected proměnné \ccc{currentVisibleTiles}. V dalším kroku je zavolána funkce 
\ccc{SetupLevelConnectors}, jenž projde všechny viditelné dlaždice vedoucího do jiných úrovní. Pro
každou tuto dlaždici dojde pak voláním funkce \ccc{ConnectLevels} k propojení dané dlaždice s další
úrovní. Poslední akcí je přiřazení úrovně, v které se hráč vyskytuje, do proměnné \ccc{CurrentLevel}.

Funkce \ccc{ConnectLevels} načte danou úroveň pomocí funkce \ccc{LoadLevel}, která tak učiní skrze builder.
Načtená úroveň je pak uložena do kolekce \ccc{ActiveLevels}, ve které jsou vždy tři poslední úrovně.
Dlaždice, které propojují herní úrovně, by měly implementovat rozhraní \ccc{ILevelConnector}.
Funkce \ccc{ConnectLevels} pak nastaví cílovou dlaždici do vlastnosti \ccc{ILevelConnector.NextLevelEnter}.
Dlaždice implementující toto rozhraní by měla zajistit její propojení s dlaždicí \ccc{ILevelConnector.NextLevelEnter}.
Všechny funkce zmíněné v této sekci jsou virtuální, a proto je možné jejich chování upravit přetížením.

\imgx{core-tileUpdate}{Ilustrace funkce jádra.}

\subsection{Aktualizace a rendering}
MonoGame zajišťuje herní smyčku, skrze kterou je pak třeba na enginu volat funkce \ccc{Update} a \ccc{Draw}.

V každém zavolání funkce \ccc{Update} se provede aktualizace všech herních úrovní v kolekci \ccc{ActiveLevels}.
Herní úroveň reprezentuje typ \ccc{DungeonLevel}, který má v sobě uložené dlaždice, obtížnost a objekty vyžadující
aktualizaci -- které se u něj zaregistrovaly \vref{engine-core-section}. Funkce \ccc{DungeonLevel.Update} pak 
zavolá na všech zaregistrovaných objektech  funkci \ccc{IUpdate.Update}. Všechny tyto objekty musí implementovat
rozhraní \ccc{IUpdate} a musí se samy starat o odregistrování z kolekce, když už aktualizaci nevyžadují. Dále je volána 
funkce \ccc{ILeader.Update} na hráči. Při každém provedení aktualizace se ještě zavolá virtuální funkce 
\ccc{UpdateLight}. Proces reprezentuje obrázek \ref{core-update-draw}.

Funkce \ccc{UpdateLight} přiřadí do proměné \ccc{Light} hodnotu určující úroveň světla, která je v setteru
vlastnosti přepočítána na vzdálenost, po kterou se vykreslují dlaždice. Getter pak vrací již samotnou vzdálenost,
nikoliv hodnotu světla. Hodnota světla je 0 až 5, kde 0 reprezentuje největší osvětlení. Takto je to nastaveno
z důvodu kompatibility se zdrojovými kódy originální hry \cite{DMDecompilation}. 
 Funkce projde všechny šampiony v kolekci \ccc{ILeader.PartyGroup} a nalezne všechny 
objekty implementující rozhraní \ccc{ILightSource}. Na základě hodnot \ccc{ILightSource.LightPower} vypočte 
výslednou hodnotu osvětlení. Tento výpočet lze změnit přetížením funkce. 

V každém zavolání funkce \ccc{Draw} se potom provede vykreslení všech dlaždic v kolekci \ccc{currentVisibleTiles}
skrze jejich renderer \vref{renderer-interactor}. Dále jsou zavolány funkce \ccc{ILeader.Draw} pro vykreslení objektů
ve správě hráče a virtuální funkce \ccc{DrawMiniMap}, která provede vykreslení minimapy.

\imgx{core-update-draw}{Ilustrace aktualizace a vykreslování z pohledu jádra. }

\section{Dlaždice -- \ccc{ITile}}
Nejobecnější strukturu dlaždice definuje rozhraní \ccc{ITile}. Každá dlaždice musí mít definované sousedy,
to zajišťuje položka \ccc{Neighbors} typu \ccc{TileNeighbors}. Tento typ implementuje rozhraní \ccc{INeightbors},
které vyžaduje pouze enumerátor dvojic se směrem a dlaždicí. Směr reprezentuje struktura \ccc{MapDirection}, kde
se jednotlivé směry dají získat skrze její statické členy. Třída \ccc{TileNeighbor} potom implementuje ještě
pomocné funkce a vlastnosti pro jednoduší práci se sousedy. Pomocí této vlastnosti se objekty mohou pohybovat
mezi dlaždicemi \cc{layout-reserve}. Po vstupu objektu na dlaždici je třeba zavolat na předchozí dlaždici funkci \ccc{OnObjectLeft} a
na nové dlaždici funkci \ccc{OnObjectEntered}. Díky tomu může dlaždice reagovat na vstup resp. odchod objektů --
což je použité například pro přepínače na podlaze. Další vlastností dlaždice je \ccc{LayoutManager}, který 
musí používat entity při pohybu po dlaždicích a mezi nimi. \ccc{LayoutManager} je třída poskytující správu prostoru
na dlaždici, tak aby každý prostor zaujímala pouze jedna entita \vref{layout-manager-section}. Před pohybem entity je
tedy ještě třeba zarezervovat (reserve) skrze \ccc{LayoutManager} cílový prostor na dlaždici a po dokončení pohybu
je naopak třeba uvolnit prostor předchozí (free). Poslední položkou potřebnou pro pohyb mezi dlaždicemi je vlastnost
\ccc{IsAccessible}, která určuje, zda lze na dlaždici vstoupit.

\imgx{layout-reserve}{Ilustrace pohybu mezi prostory a dlaždicemi. }

Pro implementaci funkce přepínačů je třeba zajistit komunikaci mezi dlaždicemi \vref{actuator-message-representation}.
Za tímto účelem obsahuje dlaždice vlastnosti pro změnu jejího stavu. Buď lze obsah dlaždice aktivovat přímo
pomocí funkce \ccc{ActivateTileContent} resp. \ccc{DeactivateTileContent} nebo pomocí zaslání zpráv, k jejichž
příjetí slouží funkce \ccc{AcceptMessageBase}. Konkrétní stav je obsahuje pak vlastnost \ccc{ContentActivated}.


V poslední řadě rozhraní reprezentující dlaždice obsahuje prvky: 
\begin{itemize}
\item \ccc{Position} -- absolutní pozice od počátku souřadnic,
\item \ccc{GridPosition} -- souřadnice dlaždice na mřížce, 
\item \ccc{Drawables} -- do této kolekce se mohou zaregistrovat objekty implementující rozhraní \ccc{IRenderable}, 
	které se nechtějí registrovat u dlaždice pomocí funkcí pro vstup a výstup a zároveň se potřebují renderovat, 
\item \ccc{ObjectEntered} resp. \ccc{ObjectLeft} -- události vyvolané při vstupu resp. odchodu objektu,
\item \ccc{Level} -- reference na level, ve kterém se dlaždice nachází,
\item \ccc{IsInitialized} -- určuje, zda je dlaždice plně inicializovaná \vref{level-inicialization},
\item \ccc{Initialized} -- tato událost je dlaždicí vyvolána pouze jednou a to v momentě, kdy jsou všechny její části inicializované.
		Tuto událost využívají živé entity k určení doby jejich obživnutí.
\end{itemize}

Všechny třídy s dlaždicemi jsou ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Tiles}.

\subsection{Inicializace dlaždic}
Jak již bylo zmíněno v analýze \vref{level-inicialization}, k inicializaci dlaždic jsou použity tzv. inicializátory. Inicializátor
obsahuje vlastností, které by normálně byly předány jako parametry v konstruktoru. Ovšem v moment předávaní
inicializátoru do konstruktoru, inicializátor ještě nemusí mít naplněné všechny hodnoty. Namísto toho má události \ccc{Initializing}
resp. \ccc{Initialized}, které jsou vyvolány při resp. po inicializaci. Na tuto událost je třeba zaregistrovat
inicializační funkci, která zkopíruje data z inicializátoru do samotného objektu. Pro každou úroveň hierarchie
dědičnosti jsou určeny zvláštní vlastnosti a zvláštní inicializační události. Rodičovské události  inicializátoru jsou vždy
po zdědění rodičovského inicializátoru zakryty novými inicializačními událostmi pro danou úroveň dědičnosti.
Tento způsob je použit pouze pro inicializaci dlaždic. Pro jiné objekty, může inicializátor sloužit pouze jako 
objekt udržující parametry, které jsou hned v konstruktoru inicializované. 

\subsection{Implementace dlaždic}
Částečnou implementaci rozhraní \ccc{ITile} zajišťuje abstraktní třída \ccc{Tile}, která definuje virtuálně \ccc{LayoutManager}.
Dále abstraktně deklaruje kolekci \ccc{SubItems}, která obsahuje všechny objekty na dlaždici. Objekty, které 
implementují rozhraní \ccc{IRenderable}, jsou potom skrze tuto kolekci vykreslovány.
Dlaždice také má tzv. strany, a jsou to buď stěny, strop nebo podlaha \cc{tile-sides}.
Pro tyto strany pak abstraktně deklaruje kolekci \ccc{Sides}, jejímž stěnám pak přeposílá
případné zprávy, které přišly na tuto dlaždici skrze metodu \ccc{AcceptMessageBase}.
Dále implementuje také funkce \ccc{OnObjectEntered} resp. \ccc{OnObjectLeft} tak, že vyvolá jejich odpovídající událost.
Proto je pří případném přetížení těchto funkcí v potomkovi nutné zavolat implementaci rodiče. Všechny
předchozí popsané funkce je možné přetěžovat v potomkovi, a tak přizpůsobit prováděné akce.
V poslední řadě se tento inicializátor stará o inicializaci pozic na mřížce, úrovně a sousedů skrze \ccc{TileInicializator}. 

\imgx{tile-sides}{3D ilustrace dlaždice a jejích stran.}

Přímý generický potomek předchozí třídy \ccc{Tile\textlangle TMessage\textrangle}, kde \ccc{TMessage} je alespoň \ccc{Message},
poskytuje možnost přijímat v potomcích zprávy vlastního typu \vref{actuator-representation}. V případných potomcích teto třídy 
lze naimplementovat funkci \ccc{AcceptMessage}, která přijímá zprávy typu \ccc{TMessage}. Tato třída přetěžuje a zároveň 
uzavírá metodu \ccc{AcceptMessageBase} tak, že deleguje zprávy typu \ccc{TMessage} do metody \ccc{AcceptMessage}. 
Naopak základní implementace metody \ccc{AcceptMessage} je zavolání právě rodičovské implementace \ccc{AcceptMessageBase}. 
Při případném přetěžování této funkce je třeba rozhodnout, zda je nutné volat implementaci rodiče. Všechny dlaždice,
které dědí ze třídy \ccc{Tile\textlangle TMessage\textrangle}, vytváří dva potomky. První z nich je pro případné rozšiřitele,
a proto ponechává typový parametr, druhý pak specifikuje typový parametr na obecný typ \ccc{Message}.

\subsubsection{Dlaždice podlaha -- \ccc{FloorTile\textlangle TMessage\textrangle}}
Tato dlaždice implementuje funkci všech jejích stran \cc{tile-sides}. Na stranách, kde
nemá dlaždice sousedy jsou přidány stěny, které mají podporu pro přepínače \vref{dungeon-objects} a dekorace \vref{actuator-analyza}.
Dále je přidána strana na místo stropu a podlahy. Strana s podlahou pak může obsahovat přepínač a je na ni možné odkládat
či z ni odebírat předměty. Dlaždice také deleguje veškeré vstupy resp. odchody objektů do samotné strany podlahy
typu \ccc{FloorSide} \vref{tile-sides-section} a to kvůli podpoře odkládání předmětů na zem.

\subsubsection{Další implementace dlaždic}
Další dlaždice převážně využívají dlaždici podlahu pomocí dědičností. Výjimkou jsou například schody,
které jsou zároveň příkladem dlaždice implementující rozhraní \ccc{ILevelConnector}. Engine při načtení 
levelu nastaví vlastnost \ccc{ILevelConnector.NextLevelEnter} na odpovídající dlaždici \vref{engine-level-management}.
Při změně předchozí vlastnosti provede dlaždice nastavení sousedů vedoucích do dalšího levelu a používá k tomu vlastní 
implementaci sousedů přetížením vlastnosti \ccc{Neighbors}. Tato možnost je použita ještě u jámy, kvůli propadu do nižšího levelu. 
Rozhraní spojující levely je ještě použito u teleportu, kde při vstupu správného objektu na teleportační dlaždici 
dojde k teleportaci objektu na dlaždici \ccc{ILevelConnector.NextLevelEnter}. Další dlaždicí jsou dveře, které opět 
dědí z podlahy a navíc implementují rozhraní \ccc{IHasEntity}. Toto rozhraní obsahuje vlastnost typu \ccc{Entity},
která reprezentuje neživou entitu na dlaždici. S touto entitou můžou pak pracovat akce, kterými lze dveře rozbít.
Poslední dlaždici reprezentuje třída \ccc{LogicTile}, na kterou nelze vstoupit a slouží pouze jako podpora
pro přepínače \vref{actuators-implementation}.

\subsection{Strany dlaždic -- \ccc{ITileSide}}\label{tile-sides-section}
Jak již bylo naznačeno \cc{tile-sides}, dlaždice mohou mít strany, které jsou buď stěny, podlaha nebo strop.
Každou tuto stranu reprezentuje samostatný objekt, který má svůj renderer-interactor \vref{renderer-interactor}. 
Toto rozhraní vyžaduje pouze položku pro renderer a funkci pro přijímání základních zpráv \ccc{Message}. 
Tato funkce je zde z kompatibilních důvodu s originální hrou, kdy texty na zdech mohou být těmito 
zprávami skryty či zobrazeny.

Následuje seznam jednotlivých implementací:
\begin{itemize}

\item \ccc{TileSide} -- reprezentuje pouze holou stěnu bez žádných funkcí, která obsahuje
	pouze vlastnost typu \ccc{MapDirection} určující její pozici. 

\item \ccc{ActuatorTileRenderer} -- přímý potomkem předchozí strany, který navíc obsahuje přepínač a renderer, 
	jenž se navíc stará o jeho vykreslování a interakci. 

\item \ccc{TextTileSide} -- opět přímý potomek první strany, jejíž renderer navíc zobrazuje na zdi text. Viditelnost textu lze změnit zasláním zprávy
	této straně. 

\item \ccc{FloorTileSide} -- tato strana obsahuje čtyři úložiště,
na které může hráč pokládat předměty. Je to jedno z míst, kde je potřeba komunikovat s rodičovskou dlaždicí, k tomu
slouží událost \ccc{SubItemsChanged}, která se vyvolá vždy, když byl nějaký předmět odebrán nebo přidán.
Pomocí enumerátoru tohoto objektu je potom možné získat obsažené objekty. Předměty lze pak na podlahu přidávat dvěma 
způsoby, přičemž oba pomocí události informují rodičovskou dlaždici o změně jejího obsahu. První možností je položení 
předmětu přímo z ruky hráče pomocí renderer-interactoru. Druhý způsob je zavolání metody \ccc{OnObjectEntered} resp. \ccc{OnObjectLeft} 
objevující se například při teleportaci nebo hodu předmětu. Celou situaci zobrazuje obrázek \ref{floor-side}.

\item \ccc{ActuatorFloorTileSide} -- přímý potomek předchozí strany podlahy, který navíc přidává na podlahu nášlapný přepínač.

\end{itemize}

\imgx{floor-side}{Ilustrace komunikace podlahy s její dlaždicí při přidávání předmětu.}

\section{Přepínače -- \ccc{IActuatorX}}\label{actuators-implementation}

Za přepínači stojí rozhraní \ccc{IActuatorX}, které vyžaduje pouze API pro příjem zpráv typu \ccc{Message} -- pro dodržení
kompatibility s původní hrou. Toto rozhraní pak implementuje třída \ccc{ActuatorX}, která reprezentuje přepínače používající 
pro jejich funkci senzory z originální hry \vref{actuator-analyza}. Kromě toho dále existují implementace přepínačů, které jsou provedeny
jiným způsobem.

Třídy související s přepínači a senzory lze nalézt ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Actuators}.

\subsection{Implementace obecných přepínačů}\label{general-sensors}
Tato sekce pojednává o přepínačích, které ke své funkci nepoužívají senzory. V tomto enginu jsou použity pro 
dekorace, které provádějí nějakou funkci. K těmto dekoracím v originální hře nenáleží žádné senzory. 
Studií dekompilovaného kódu originální hry \cite{DMDecompilation} se ukázalo, že některé akce jsou fixovány 
na konkrétní typy dekorací. Například pro dekorace s výklenky je naimplementována možnost vkládaní předmětů.
Jelikož tyto dekorace mohou být i součástí senzorů, bylo zapotřebí, aby objekty reprezentující dekorace
implementovaly rozhraní \ccc{IActuatorX}, a tak bylo možné naimplementovat funkce pro jejich interakci.

U těchto přepínačů lze zvolit jejich vnitřní formát. Existující implementace jsou:
\begin{itemize}
\item \ccc{DecorationItem} -- stará se pouze o rendering dekorace, který zajišťuje třída \ccc{DecorationRenderer}. 
\item \ccc{Alcove} -- reprezentuje dekoraci výklenku, o jehož rendering a interakci se stará třída \ccc{AlcoveRenderer}. 
\item \ccc{ViAltairAlcove} -- potomek třídy \ccc{Alcove}, který se navíc stará o reinkarnaci šampionů.
\end{itemize}

\subsection{Implementace přepínačů se senzory}
Tyto přepínače se skládají z řady senzorů, které mohou provádět následující akce:

\begin{itemize}
\item změna stavu vzdálené dlaždice,
\item zarotování sekvencí senzorů přepínače,
\item přidání zkušeností hráči.
\end{itemize}

Při pokusu o aktivaci přepínače dojde postupně k aktivaci všech jeho senzorů.
Senzory pak mohou být aktivovány následujícími způsoby:

\begin{itemize}
\item kliknutím myši na dekoraci senzoru, pokud je senzor na zdi, 
\item vstupem resp. odchodem hráčovi skupiny na dlaždici resp. z dlaždice, 
\item zprávou vyslanou jiným senzorem.
\end{itemize}

Více viz sekce \ref{actuator-analyza}.

\subsubsection{Implementace senzorů}

Každý typ senzoru má jinou podmínku aktivace. Senzory se dělí na senzory použité na podlaze, zdi a
na speciální tzv. logické senzory.

Hlavní třídou reprezentující senzor je abstraktní třída \ccc{SensorX}. Tato třída obsahuje společné funkce,
které jsou využívány jejími potomky. Dále také definuje vlastnosti, které lze rozdělit do tří skupin.
Tyto vlastnosti jsou inicializovány inicializátorem \vref{level-inicialization}, který slouží pouze jako datový nosič.
Jde o inicializátor, který reprezentuje třída \ccc{SensorInitializerX}. Pro inicializaci potomků jsou 
používány poděděné implementace tohoto inicializátoru.

Vlastnosti senzorů třídy \ccc{SensorX}:
\begin{itemize}
\item Obecné vlastnosti:
	\begin{itemize}
	\item \ccc{Delay} -- opoždění akce v milisekundách, po kterém se provede akce senzoru.
	\item \ccc{LocalEffect} -- informace, zda-li je akce určena lokálně pro rodičovskou dlaždici nebo pro vzdálenou.
	\item \ccc{OnceOnly} -- informace, zda-li je senzor možné aktivovat pouze jednou.
	\item \ccc{RevertEffect} -- u většiny přepínačů obrátí efekt výsledné akce, nicméně přesný význam si stanoví vždy konkrétní senzor. 
	\item \ccc{Audiable} -- informace určující, zda po aktivaci dojde k přehrání zvuku.  (v tomto enginu není použit)
	\item \ccc{GraphicsBase} -- reprezentuje dekoraci a zároveň přepínač obecného typu implementující rozhraní \ccc{IActuatorX}.
			Pokus o aktivaci tohoto přepínače se provádí, pouze pokud je zobrazena dekorace \cc{decoration-actuator}.
	\end{itemize}

\item Vlastnosti pro lokální akci:
	\begin{itemize}
	\item \ccc{Rotate} -- informace určující, zda-li se má seznam senzorů při aktivaci zarotovat.
	\item \ccc{ExperienceGain} -- informace určující, zda-li se mají hráči po aktivaci přidat zkušenosti.
	\end{itemize}

\item Vlastnosti pro vzdálenou akci:
	\begin{itemize}
	\item \ccc{Effect} -- určuje, jaká zpráva je odeslaná na cílovou dlaždici.  (Akce zprávy může být obrácená, pokud je nastavena vlastnost \ccc{RevertEffect}).
	Hodnoty efektu jsou následující:
		\begin{itemize}
		\item Aktivace 
		\item Deaktivace
		\item Přepnutí stavu
		\item Drž -- tento stav nelze odeslat ve zprávě a je na senzoru, aby ho interpretoval pomocí aktivace či deaktivace.
		\end{itemize}
	\item \ccc{Specifier} -- směr použitý v odeslané zprávě, který může být interpretován jako číslo (lze získat pomocí \ccc{MapDirection.Index}).
	\item \ccc{TargetTile} -- reference na cílovou dlaždici.
	\end{itemize}
\end{itemize}

Kromě předchozích vlastností obsahuje tato třída funkce pro vykonání akcí senzorů. Pokud je efekt senzoru vzdálený, funkce  \ccc{TriggerEffect} odešle zprávu 
na danou cílovou dlaždici s daným zpožděním \ccc{Delay}. Zpoždění je prováděno pomocí asynchronních funkcí \vref{async-engine}. Jinak provede akci pro lokální efekt, který lze 
také vykonat přímo zavoláním funkce \ccc{TriggerLocalEffect}. Tyto funkce lze použít pouze v potomcích.

Následující třídy jsou přímými potomky třídy \ccc{SensorX}:

\begin{enumerate}
\item\label{floor-tile-sensor} \ccc{FloorSensor} -- tyto senzory lze vložit pouze do přepínačů, které mohou být na podlaze.
\item\label{wall-tile-sensor} \ccc{WallSensor} -- tyto senzory lze vložit pouze do přepínačů, které mohou být na stěně.
\item \ccc{LogicGateSensor} resp. \ccc{CounterSensor} -- pro tyto senzory existuje speciální dlaždice \ccc{LogicGateTile}
\end{enumerate}

Senzory z bodu \ref{floor-tile-sensor} a \ref{wall-tile-sensor} mají funkci \ccc{TryTrigger}, která se pokusí senzor 
aktivovat a pokud uspěje, stará se o provedení efektu. Zda-li se senzor aktivuje stanoví abstraktní funkce \ccc{TryInteract},
kterou implementují potomci. Pro každou variantu senzoru mají funkce odlišné parametry. Pokud je třeba modifikovat způsob 
provedení výsledného efektu, je možné funkce \ccc{TryTrigger} přetížit.

Kromě předchozích senzorů ještě existují tzv. logické senzory (viz \ref{floor-tile-sensor}). První z nich \ccc{LogicGateSensor} funguje 
jako logické hradlo, které má k dispozici osm bitů. Čtyři z nich jsou nastaveny při designu na hodnoty a ostatní na nuly. 
S druhou čtveřicí lze pak manipulovat pomocí zpráv. Index směru zprávy určuje, kolikátý bit se má ovlivnit. Tento bit
je pak ovlivněn akcí zprávy. Pokud jsou obě čtveřice stejné, je vyvolán efekt senzoru. Dalším
senzorem je \ccc{CounterSensor}, který má dané číslo. Aktivační zprávy toto číslo poté navyšují a deaktivační zprávy
ho snižují. Pokud je číslo  nula, je vyvolán efekt.
 
\subsubsection{Implementace přepínačů používající senzory}

Rodiči těchto přepínačů je třída \ccc{Actuator}. Tato třída poskytuje funkci pro zarotování senzory přepínače, kterou
lze vyvolat pouze z potomků. Zda-li se mají senzory zarotovat se určuje nastavením vlastnosti \ccc{Rotate}, která se po jeho 
provedení nastaví zpět na false. Samotné zarotování se pak provede zavoláním funkce \ccc{ProcessRotationEffect}.

Prvním potomkem předchozí třídy je třída \ccc{FloorActuator}, která může obsahovat pouze senzory určené
na podlahu tj. \ccc{FloorSensor}. Pokus o její aktivaci se provádí funkcí \ccc{Trigger}. Jako první parametr se jí předává objekt,
který vstupuje resp. odchází z dlaždice, dále seznam všech objektů na dlaždici a naposled informace, zda objekt
vstupuje či odchází. Pro přepínač je vytvořena speciální podlaha \ccc{ActuatorFloorSide}, která se stará 
o volání funkce \ccc{Trigger}.

Dalším potomkem je třída \ccc{WallActuator}, která může obdobně obsahovat pouze senzory určené na zeď tj. \ccc{WallSensor}.
Pokus o její aktivaci se provádí opět funkcí \ccc{Trigger}, která má jediný parametr typu \ccc{ILeader}. Pro přepínač
je určena strana \ccc{ActuatorWallTileSide}. Funkce \ccc{Trigger} je pak volána skrze renderer dané strany. 
Ta se pak pokusí postupně aktivovat všechny senzory a navíc se pokusí aktivovat přepínač zobrazené dekorace \cc{decoration-actuator}.

\imgx{decoration-actuator}{Ilustrace struktury přepínače se senzory.}

Poslední speciální implementací je třída \ccc{LogicActuator}, která může obsahovat logické senzory.
Komunikace se senzory probíhá pomocí zasílání zpráv. Pro tento přepínač je vytvořena speciální dlaždice,
na kterou nelze hráčem vstoupit. Tato dlaždice je reprezentována třídou \ccc{LogicTile}. 

\imgx{actuator-sensor-hierarchii}{Ilustrace hierarchie přepínačů a senzorů.}

\section{Herní entity}

Za deklarací neživých entit stojí rozhraní \ccc{IEntity}, které definuje funkci \ccc{GetProperty} pro získání vlastnosti dané entity.
Za živými entitami stojí naopak rozhraní \ccc{ILiveEntity}, které navíc disponuje funkcí \ccc{GetSkill} pro získání schopností. Dále
také deklaruje:

\begin{itemize}
\item tělo entity
\item způsob rozmístění entity na dlaždici
\item relace s dalšími entitami
\end{itemize}

\subsection{Implementace vlastností entit}

Vlastnost deklaruje rozhraní \ccc{IProperty}, které obsahuje následující atributy:
\begin{itemize}
\item \ccc{Value} -- stanovuje aktuální hodnotu dané vlastnosti. V jejím getteru a setteru se typicky provádějí 
	kontroly okrajových hodnot a případné reakce na ně.
\item \ccc{BaseValue} -- maximální hodnota, které může vlastnost nabýt, pokud není nějak modifikovaná.
\item \ccc{MaxValue} -- určuje maximální hodnotu včetně modifikací. 
\item \ccc{AdditionalValues} -- je to kolekce typů \ccc{IEntityPropertyEffect} obsahující modifikace dané vlastnosti.
\item \ccc{Type} -- je to vlastnost typu \ccc{IPropertyFactory}, která reprezentuje typ vlastnosti. Entita na základě 
	tohoto typu potom vrací odpovídající vlastnost. Pro usnadnění tvorby unikátních typů existuje generická třída \ccc{PropertyFactory}, 
	která má jako typový parametr typ alespoň \ccc{IProperty}. Tato třída se řídí vzorem singleton, jejíž jedinou instanci
	lze získat přes statickou položkou \ccc{Instance}. Takto lze pak generovat typy pomocí třídy reprezentující vlastnost.
\end{itemize}

Pro usnadnění práce existuje implementace rozhraní \ccc{IProperty} a to třída \ccc{Property}. Tato třída definuje 
maximální hodnotu jako součet základních hodnot a sumu modifikujících hodnot. Dále při nastavení konkrétní hodnoty ořezává
hodnotu do povoleného intervalu, který je mezi nulou a maximální hodnotou. Také definuje událost vyvolanou při změně hodnoty.
Všechny vlastnosti jsou deklarovány abstraktně nebo virtuálně. 

Některé vlastnosti mohou požadovat přístup k jiným vlastnostem či přístup k rodičovské entitě. V takovém
případě je na programátorovi, jak takového cíle dosáhne. Typicky se v takovém případě předá v konstruktoru
potřebná vlastnost nebo se vytvoří událost, která danou závislost deleguje vně. 

Seznam předdefinovaných vlastností je možné najít ve jmenném prostoru \ccc{DungeonMasterEngine.DungeonContent.Entity.Properties}.
Jak již bylo zmíněno \vref{entity-properties}, může nastat, že daná entita vlastností nedisponuje. V takovém případě 
je vrácena instance třídy \ccc{EmptyProperty}. 

\subsection{Implementace dovedností entit}

Dovednosti deklaruje rozhraní \ccc{ISkill}, které obsahuje následující atributy:
\begin{itemize}
\item \ccc{SkillLevel} -- udává úroveň, na které je daná dovednost včetně úrovní získaných kouzelnými předměty.
\item \ccc{BaseSkillLevel} -- udává úroveň bez úrovní získaných kouzelnými předměty.
\item \ccc{Experience}  -- určuje celkovou dosavadní hodnotu zkušeností.
\item \ccc{TemporaryExperience} -- určuje dočasné zkušenosti, které můžou být jak přidávány tak odebírány.
\item \ccc{BaseSkill} -- je reference na základní dovednost \vref{analysis}. Pokud je daná schopnost 
	už základní, je hodnota \ccc{null}.
\item \ccc{AddExperience} --  umožňuje přidat zkušenosti.
\item \ccc{Type} -- je to vlastnost typu \ccc{ISkillFactory}, která reprezentuje typ dovednosti.  Entita na základě 
	tohoto typu potom vrací odpovídající dovednost. Stejně jako u vlastností, je možné tyto reprezentanty vytvářet pomocí generické třídy \ccc{SkillFactory}. 
\end{itemize}

Konkrétní algoritmus přepočítávání zkušeností na úrovně dovedností záleží vždy na konkrétní implementaci.  

Třída \ccc{SkillBase} implementuje získávání zkušeností schopností jako v originální hře. Všechny schopnosti 
využívající tuto třídu jsou ve jmenném prostoru \ccc{DungeonMasterEngine.DungeonContent.Entity.Skill}. Stejně jako
u vlastností i zde entita nemusí mít dotazovanou schopnost. V takovém případě vrací instanci třídy \ccc{EmptySkill}.

\subsection{Tělo -- \ccc{IBody}}

Následující API umožňuje pro entity vytvořit různé druhy těl.
Tělo se skládá z částí, které mohou sloužit jako úložiště. Dále pak existují externí
úložiště tzv. inventáře. API je navržené tak, aby dovolovalo definovat různé druhy úložišť a těl. 
Engine obsahuje pouze implementaci pro lidské tělo tj. třída \ccc{HumanBody}.
Tělo entity je definováno rozhraním \ccc{IBody} a obsahuje následující atributy:

\begin{itemize}
\item \ccc{BodyParts} -- obsahuje seznam částí těla,
\item \ccc{Storages} -- obsahuje seznam všech úložišť včetně částí těla,
\item \ccc{GetStorage} -- funkce pro vyhledání úložiště včetně částí těla,
\item \ccc{GetBodyPart} -- funkce pro vyhledání části těla. 
\end{itemize}

\subsubsection{Externí úložiště -- \ccc{IInventory}}
Každý inventář má definovanou vlastnost \ccc{Type}, což je typ úložiště, který reprezentuje instance třídy 
implementující rozhraní \ccc{IStorageType}. Dále pak definuje readonly kolekci \ccc{Storage} pro ukládání předmětů.
A v poslední řadě obsahuje funkce pro přidávaní a odebírání předmětů z úložného prostoru tj. \ccc{TakeItemFrom}, \ccc{AddItemTo}, \ccc{AddItem},
\ccc{AddRange}. Třída \ccc{Inventory} implementuje všechny funkce inventáře a je jí tedy možno přímo použít nebo rozšířit.

\subsubsection{Část těla -- \ccc{IBodyPart}}
Část těla je definovaná rozhraním \ccc{IBodyPart}, které je potomkem rozhraní \ccc{IInventory}. Toto rozhraní navíc definuje 
následující vlastnosti: 
\begin{itemize}
\item \ccc{IsWounded} -- definuje, zda je část těla zraněna,
\item \ccc{InjuryMultipler} -- definuje pravděpodobnost zranění části těla.
\end{itemize}

Obecnou implementací rozhraní je třída \ccc{BodyPart}. 

\subsection{Rozmístění entity na dlaždici}\label{layout-manager-section}

Rozhraní \ccc{IGroupLayout} definuje obecně možné rozmístění na dlaždici. Jeho vlastnost \ccc{AllSpaces} obsahuje všechny možné prostory, které daná entita může využít.
Tyto prostory rozdělují prostor dlaždice na mřížku \cc{space-grid}, která nemusí být rovnoměrná.
Jednotlivě prostory jsou reprezentovány rozhraním \ccc{ISpace}. Dale API vyžaduje funkci \ccc{GetToNeighbour}, která nalezne cestu skrze prostory
na cílovou sousední dlaždici \cc{space-route}. Funkce \ccc{GetToSide} vrací cestu k libovolné ze stran dlaždice. Jednotlivé články cesty jsou 
reprezentovány rozhraním \ccc{ISpaceRouteElement}. Poslední funkce musí umět vytvořit z prostoru a dlaždice článek cesty,
tedy \ccc{ISpaceRouteElement}.  

\imgx{space-grid}{Ilustrace rozdělení dlaždice na prostory. }

Rozhraní \ccc{ISpace} musí definovat, k jakým stranám dlaždice je prostor přilehlý. Dále musí pomocí obdélníku definovat prostor, který na dlaždici využívá.
Celý prostor dlaždice je pak definovaný na pole o velikosti 1000x1000. Přičemž souřadnice rostou
shora dolů a zleva doprava. Nahoře je pak sever, vpravo východ, dole jih a vlevo západ. Kromě toho také musí definovat sousední
prostory, k čemuž využívá generické rozhraní \ccc{INeighborable}. Ilustrace viz obrázek \cc{tile-spaces}

\imgx{space-route}{Ilustrace nalezení cesty na sousední dlaždici. }

\imgx{tile-spaces}{Ilustrace vlastností prostorů. }

Rozhraní \ccc{ISpaceRouteElement} se potom skládá pouze z prostoru, dlaždice a absolutní pozice, na které má stát daná entita.
Pro výpočet této pozice se může použít pozice dlaždice a prostor. Při při implementaci tohoto rozhraní je možné využít 
předem připravený hledač nejkratších cest pro prostory \ccc{GroupLayoutSearcher}. Pro reprezentaci sousedů prostorů mřížky 
existuje třída \ccc{FourthSpaceNeighbors}.

Celé toto rozhraní je immutable objekt, který pouze definuje prostory na dlaždici a způsob pohybu mezi nimi. Z toho důvodu
instance tříd implementující toto rozhraní mohou být singeltony. Engine definuje layout pro prostor reprezentující celou dlaždici
a pro prostory jako čtvrtiny dlaždice.

\subsubsection{Řízení obsazeného prostoru na dlaždici}

K předchozímu mechanismu je ještě třeba další část, která bude zaznamenávat samotné využité pozice na dlaždici. K tomuto 
účelu existuje třída \ccc{LayoutManager}.  Lze pomocí ní získat seznam entity na dlaždici a seznamy využitých prostorů dlaždic.
Dále poskytuje API pro přidání entity na daný prostor na dlaždici, odebrání prostoru a získání entit, které využívají 
alespoň část nějakého prostoru. Entity s různými rozmístěními mohou být na stejné dlaždici, pokud
je na ní dostatek prostoru pro obě entity \cc{layout-manager}.

\imgx{layout-manager}{Ilustrace vlastností prostorů. }

\subsection{Relace s dalšími entitami}\label{entities-relations}

Každá živá entita musí definovat vlastnost typu \ccc{IRelationManager}. Toto rozhraní musí definovat relační token typu
\ccc{RelationToken} pro danou entitu. Dále definuje funkci, která pro daný token vrátí, zda entita odpovídající danému 
tokenu je nepřátelská. Jednoduchou implementací tohoto rozhraní je třída \ccc{DefaultRelationManager}, která při 
svém vzniku definuje nepřátele. Nicméně, pokud daná implementace nevyhovuje, je čistě na programátorovi,
aby si vytvořil implementaci vlastní. K dispozici je ještě generátor unikátních tokenů a to statická třída \ccc{RelationTokenFactory}.

\subsection{Implementace entit}\label{xyz}
Engine obsahuje implementaci dvou entit: šampiony a nepřátelské entity.
Třídy související s entitami jsou ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Entity}.


\subsubsection{Šampion}
Šampion je první živá
entita a reprezentuje jej třída \ccc{Champion}. Šampion neobsahuje žádnou umělou inteligenci, je ovládán hráčem skrze
třídu \ccc{Leader}, která reprezentuje hráčovu skupinu šampionů. Inicializace vlastností a schopností probíhá přes
datový inicializér definovaný rozhraním \ccc{IChampionInitializer}. Resp. jeho předáním do konstruktoru, dále je nutné
specifikovat relační token a seznam nepřátel. Posunout daného šampiona je možné přiřazením do vlastnosti \ccc{Location}.

Zde je dobré zmínit generickou třídu \ccc{Animator}, která má dva typové parametry. První z nich je typ posouvaného 
objektu, který musí implementovat alespoň rozhraní \ccc{IMovable}. Toto  rozhraní definuje vlastnosti, pomocí kterých lze měnit
pozice daného objektu. Dalším parametrem je typ prostorů, mezi kterými se objekt pohybuje. Ten musí implementovat alespoň 
rozhraní \ccc{IStopable}, které definuje pozici, na které se má objekt postavit. Animátor poskytuje API pro plynulý
posun objektů mezi prostory.

U šampiona je tento animátor použit automaticky při změně lokace.

\subsubsection{Nepřátelské entity}

Všechny nepřátelské entity ve hře reprezentuje třída \ccc{Creature}. Vlastnosti jednotlivých typů nepřátelský entit 
jsou ve třídách typu \ccc{CreatureFactory}. Každá konkrétní instance 
nepřátelské entity má referenci na tuto třídu a její chování je ovlivněné vlastnostmi v ní obsažené. 

Tato třída definuje pro nepřátelské entity jednoduchou umělou inteligenci. K zjednodušení implementace jsou zde využity 
asynchronní funkce \vref{async-engine}. Ty jsou především využity pro vytváření zpoždění akcí pomocí 
\ccc{Task.Delay}, bez nutnosti počítání času a vracení se zpět do funkce po jeho uplynutí.

Následující příklad ukazuje použití asynchronních funkce pro životní cyklus nepřátelské entity.
Každá z funkcí \ccc{Hount}, \ccc{GoHome}, \ccc{WatchAround} provádí určitou obslužnou rutinu, při 
které může dojít k její změně. V tom případě se z funkce vyskočí a další iterace cyklu zvolí
správnou rutinu dle stavu.
\begin{code}
async void LiveAsync()
{
	while (Activated)
	{
		if (hounting)
			await Hount();
		else if (gettingHome)
			await GoHome();
		else
			await WatchAround();

		await Task.Delay(100);
	}
}
\end{code}


Složitějším příkladem může být funkce pro provádění pohybu mezi prostory. Funkce zjistí, zda je na cílové dlaždici nepřítel a
zda lze na cílový prostor dlaždice vstoupit. Pokud je na dlaždici nepřítel nebo je cílový prostor obsazený, funkce
vrátí neúspěch. Jinak je proveden posun mezi prostory dlaždic pomocí animátoru. V tomto příkladě
je navíc funkce \ccc{animator.MoveToAsync} implementována pomocí future a promise, která se splní 
po dokončení pohybu. Aktualizace samotného pohybu je potom prováděna synchronně v metodě \ccc{animator.Update}.
Po dokončení pohybu je nastavena future a tak dojde k pokračování kódu funkce.

\begin{code}
async Task<bool> MoveToSpace(ISpaceRouteElement destination)
{
   bool EnemyAtTile = destination.Tile.LayoutManager.Entities
      .Any(x => RelationManager
	     .IsEnemy(x.RelationManager.RelationToken));

   if (!EnemyAtTile && destination.Tile.LayoutManager
	     .TryGetSpace(this, destination.Space))
   {
      //free previous location
      location?.Tile.LayoutManager
         .FreeSpace(this, location.Space);
      await animator
	     .MoveToAsync(this, destination, setLocation: true);
      return true;
   } else { 
      return false;
   }
}
\end{code}

Následuje seznam funkcí a jejich popis použitých pro simulování inteligence. Všechny tyto funkce je možné přetěžovat.
\begin{itemize}

\item \ccc{Live} -- V této funkci je nekonečný cyklus, který volá obslužné rutiny podle stavu entity. Jsou to:
	\begin{itemize}
    \item Lov -- entita spatřila nepřítele a pronásleduje ho, 
    \item Cesta domů -- entita pronásledovala nepřítele, kterého následně ztratila, proto jde domů tj. na místo svého vzniku,
    \item Hlídkování -- entita hlídkuje v okolí oblasti svého vzniku.
	\end{itemize}

\item \ccc{FindEnemies} -- Pomocí prohledávání do šířky se pokusí najít entity s nepřátelským tokenem. Maximální hledaná oblast
je určena dle vlastností nepřátelské entity. Pokud je nepřítel nalezen, nastaví proměnou \ccc{hountingPath}.

\item \ccc{MoveToSpace} -- Přesune entitu mezi prostory pomocí animátoru a nastaví správně použité prostory pomocí \ccc{LayoutManageru}.

\item \ccc{MoveThroughSpaces} -- Přesune entitu přes prostory dlaždice až na cílovou dlaždici pomocí funkce \ccc{MoveToSpace}. Při každém pohybu hledá nepřátele
pomocí funkce \ccc{FindEnemies}, pokud je tak nastaveno parametrem funkce. Pokud nějaké najde, přeruší pohyb.

\item \ccc{MoveToNeighbourTile} -- Posune entitu na určenou dlaždici přes prostory dlaždice pomocí funkce \ccc{MoveThroughSpaces}.
 Pokud je cesta nepřístupná vrátí \ccc{false}.

\item \ccc{GoHome} -- Entita jde domů podle cesty uložené v proměnné \ccc{homeRoute} a poté ji nastaví na \ccc{null}. 
         Mezi dlaždicemi se posunuje pomocí funkce \ccc{MoveToNeighbourTile}.

\item \ccc{FindNextWatchLocation} -- Pomocí prohledávání do šířky z místa objevení entity nalezne dlaždici, na které dlouho
entita nebyla a vrátí k ní cestu.

\item \ccc{WatchAround} -- Pomocí funkce \ccc{FindNextWatchLocation} nalezne cestu na další místo k hlídkování. Poté jde na dané místo
 pomocí funkce \ccc{MoveToNeighbourTile}.

\item \ccc{Fight} -- Provede útok na nepřítele.

\item \ccc{PrepareForFight} -- Dostane se co nejblíže k dlaždici, na které je nepřítel a zahájí útok pomocí funkce \ccc{Fight}.

\item \ccc{GetPathHome} -- Pokusí se nalézt cestu domů. Pokud ji nalezne nastaví \ccc{homeRoute}.

\item \ccc{EstablishNewBase} -- Nastaví výchozí dlaždici na nynější.

\item \ccc{Hount} -- Entita pronásleduje nepřítele na poslední místo, kde ho spatřila. Pokud je nepřítel na sousední dlaždici, připraví
se k útoku pomocí funkce \ccc{PrepareForFight}. Pokud nepřítele ztratí, pokusí se najít cestu domů pomocí \ccc{GetPathHome}. Pokud
cestu nenalezne, založí si domov tam, kde je pomocí funkce \ccc{EstablishNewBase}.

\end{itemize}

K prohledávání do šířky se používá třída \ccc{BreathFirstSearch} nebo některý její potomek. 

\section{Předměty}
Předměty reprezentuje rozhraní \ccc{IGrabableItem}. Jak již bylo zmíněno v analýze \vref{item-factories}, každý předmět musí mít referenci na svoji 
factory minimálně typu \ccc{IGrabableItemFactoryBase}. Dále musí definovat vlastnost \ccc{Location} určující prostor dlaždice, na kterém se nachází. 
Přiřazení do této vlastnosti by mělo vyvolat přidání daného předmětu na danou dlaždici. Existují i případy, kdy toto není 
žádoucí, a proto předměty musí ještě definovat funkci \ccc{SetLocation}, která pouze danou vlastnost nastaví. V poslední řadě musí definovat renderer.

Rozhraní factory na obecné předměty vyžaduje vlastnosti jako název, hmotnost, seznam 
možných akcí s předmětem a také definuje místa, kam lze předmět uložit.

\subsection{Implementace předmětů}
Při tvorbě vlastního předmětu je třeba vytvořit implementaci zmíněného rozhraní \ccc{IGrabableItem}. Tato implementace by 
kromě vyžadovaných položek měla obsahovat položky, které se můžou měnit pro každou instanci daného typu předmětu. 
Dále je třeba vytvořit samotnou factory na tyto předměty implementací rozhraní \ccc{IGrabableItemFactory}.
Ta by měla obsahovat všechny společné vlastnosti pro daný typ předmětu. Z toho  důvodu je dobré do vlastností 
přidat kromě rozhraním požadované reference na factory i přesně typovanou referenci, skrze kterou bude možné k 
vlastnostem přistupovat. Inspirace lze nalézt v již implementovaných třídách, které jsou v jmenném 
prostoru \ccc{DungeonMasterEngine.DungeonContent.GrabableItem}.

\section{Akce}
Akce definuje rozhraní \ccc{IAction}, které má následující položky:

\begin{itemize}
\item \ccc{Factory} -- reference na factory pro daný typ akcí.
\item \ccc{Apply} -- aplikuje akci, přičemž může použít směr, který je předaný jako parametr. Ostatní položky je třeba předat při inicializaci akce. 
	Co akce provede záleží na konkrétní implementaci. Implementované akce boje využívají směr k určení dlaždice, kam je útok aplikovaný.
\end{itemize}

Existuje ještě generický potomek, který může mít jako typový parametr potomka třídy \ccc{IActionFactory}. Toto rozhraní vyžaduje jedinou funkci
\ccc{CreateAction} pro tvorbu akcí typu \ccc{IAction}. Každá factory je pak uložena ve třídě implementující \ccc{IFactories} v jádře
enginu \vref{engine-core-section} tak, aby mohl tyto akce kdokoliv používat. 

Třída \ccc{AttackBase} obsahuje některé funkce, které používají jak útoky nepřátelský entit, tak útoky šampionů.
Třída \ccc{CreatureAttack} je jejím prvním potomkem a implementuje útoky nepřátelský entit. Třída \ccc{HumanAttack} 
je jejím druhým potomkem a je rodičem pro všechny útoky šampionů, které lze nalézt ve jmenném prostoru \ccc{DungeonMasterEngine.DungeonContent.Actions}.

Implementace akcí lze nalézt ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Actions}.

\section{Kouzla}
Kouzlo definuje rozhraní \ccc{ISpell}, které vyžaduje implementovat jedinou funkci \ccc{Run}. Tato funkce má dva parametry 
a to vyvolávající entitu a směr vyvolání kouzla. Pro každé kouzlo pak existuje factory, kterou definuje rozhraní \ccc{ISpellFactory} 
s následujícími položkami:
\begin{itemize}  
\item \ccc{CastingSequence } -- sekvence symbolů typu \ccc{ISpellSymbol}, které vyvolají kouzlo.
\item \ccc{Name} -- název kouzla. 
\item \ccc{Difficulty } -- modifikátor obtížnosti při vyvolávání kouzla. 
\item \ccc{Duration } -- doba, po kterou šampion nemůže znovu vyvolávat kouzla.
\item \ccc{Skill} -- dovednost typu \ccc{ISkillFactory} nutná pro vyvolání kouzla.
\item \ccc{SkillLevel } -- úroveň předchozí dovednosti nutná pro vyvolání kouzla.
\item \ccc{CastSpell} -- funkce, která vytvoří kouzlo typu \ccc{ISpell}.
\end{itemize}  

Za jednotlivými symboly potom stojí rozhraní  \ccc{ISpellSymbol}, které definuje název symbolu a cenu many pro každý power level
za použití symbolu. Pro samotné vyvolávání kouzel je pak použita třída \ccc{SpellCastingManager}, která implementuje rozhraní
\ccc{ISpellCastingManager}.

Implementace kouzel lze nalézt ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Magic}.

\section{Projektily -- \ccc{Projectile}}
Objekty létající vzduchem -- aniž by interagovaly s dlaždicemi, oproti tomu jak to je v případě entit --  reprezentuje třída \ccc{Projectile}.
Tato třída je použita například pro kouzla nebo při hodech předmětů. Projektily se samy zaregistrují do kolekce \ccc{DungeonLevel.Updateables},
odkud jsou následně aktualizovány. Po nárazu může projektil způsobit výbuch a zranění entitám, které reprezentuje třída \ccc{Impact}. 
Vypuštění projektilu je provedeno zavoláním asynchronní funkce \ccc{Projectile.Run} \vref{async-engine}, která provádí 
celý pohyb a zajišťuje interakci projektilu.

Projektily jsou ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.DungeonContent.Projectiles}.


\section{Renderery}
Jak bylo zmíněno v analýze, engine odděluje zobrazovací vrstvu od zbytku enginu \vref{renderer-interactor}. Všechny objekty,
které potřebují mít grafický výstup, by měly implementovat rozhraní \ccc{IRenderable}, které vyžaduje položku typu \ccc{IRenderer}. 
Stěžejní funkce tohoto rozhraní jsou funkce \ccc{Render} a \ccc{Interact}. 

Nejdůležitější z parametrů těchto funkcí je dosavadní transformace. Ta obsahuje složeninu transformací složenou z jednotlivých
transformací na cestě z kořene stromu reprezentující závislosti rendererů na sobě. Takže například kořen stromu bude renderer
dlaždice, jeho syn bude strana dlaždice, její syn bude výklenek ve zdi a její syn bude předmět ve
výklenku (list). Při takovéto reprezentaci se pak musí všechny renderované objekty posunout či jinak transformovat vůči jejich rodiči.
Tzn. každý renderer si musí zvolit pozicovací konvenci, kterou pak musí závislé renderery dodržovat. Tento způsob renderování je používán u statických objektů, jako
jsou dlaždice, stěny, výklenky a podobně. Pro pohybující se objekty je používána absolutní pozice a renderery
těchto objektů transformují objekty přímo na jejich pozici. Volba mezi těmito dvěma způsoby pozicování stojí vždy za zamyšlení.

Renderery jsou vždy dělány na míru objektu, který mají renderovat. Tzn. často se renderer v konstruktoru 
inicializuje instancí s konkretním typem. Třída této instance pak má zpravidla readonly vlastnosti,
podle kterých renderer určuje, co má vykreslovat. Jelikož implementovaná grafická vrstva je pouze ve formě proof of concept,
je co nejjednodušší a neobsahuje například animace. Nicméně ze zde popsané povahy rendererů je jasné, že 
toho může být dosaženo vytvořením událostí na renderovaných objektech, které si renderer zaregistruje.
Dovedeme si představit, že by šla s takovým návrhem velmi jednoduše udělat grafická vrstva, která bude
velmi pěkná, bude mít kvalitní 3D modely a animace. Zabralo by to jen spoustu času a byla by k tomu potřeba spousta grafiků.

Při rozšíření nějakého rendereru je třeba zjistit dosavadní transformaci, která je normálně vypočítána v rodiči.
K tomuto záměru slouží funkce \ccc{GetCurrentTransformation}, která bere jako parametr dosavadní transformaci.
Rozšířením již existujícího rendereru si lze ušetřit mnoho práce a opakujícího se kódu. Proto je takový přístup v této implementaci často použit.
Funkce popsané na začátku sekce jsou samozřejmě virtuální a jdou přetěžovat,
obsahují také jeden parametr typu \ccc{object} pro případné předávaní dodatečných dat mezi renderery. Tohoto parametru není nikde v této implementaci využito.

Jelikož renderery zásadně mění vzhled a pozici všech objektů, je nutné tuto vrstvu propojit i s interakcí.
Interakční funkce má skrze parametr typu \ccc{ILeader}  přístup k položce interactor, která je typu \ccc{object}.
Daný renderer musí vědět, pro jaký typ interactoru je a na ten si ho musí vhodně přetypovat. V této implementaci je použit paprsek  (\ccc{Ray}). 
Celý tento koncept interactoru by šel udělat genericky, ale prolínal by se celou strukturou rendererů a z toho
důvodu jsme se rozhodli v tomto místě ustoupit a udělat situaci jednoduší na úkor kontroly za překladu.

\section{Builder herních úrovní}\label{level-builder}
Nyní, když máme rozebrané všechny části enginu, které je potenciálně možné rozšířit, můžeme si vysvětlit, jak
se vše sestaví dohromady v herní úrovně.

\subsection{Vlastní implementace builderu}\label{custom-builder}
Jak již bylo zmíněno, builder musí implementovat rozhraní \ccc{IDungeonBuilder} \vref{engine-core-section}. Toto rozhraní je
potom dotazované jádrem enginu s požadavkem o načtení určité herní úrovně. Je úkolem builderu rozhodnout, jak bude jednat
v případě, že je podán několikrát dotaz na stejnou mapu. Typicky je tedy nutné rozhodnout
se, jestli načtené mapy kešovat či nikoliv. 

Správně implementovaný builder by měl načítat mapy zhruba tímto postupem. 

\begin{enumerate}

\item Vytvoření dlaždic a naplnění jejich inicializátorů. 
To znamená vytvořit strany dlaždic a přepínače či předměty v nich obsažené.

\item Nastavení sousedů dlaždic do inicializátorů. 

\item Vytvoření samotné herní úrovně \ccc{DungeonLevel}.

\item Dokončení inicializace dlaždic skrze inicializátory. 

\item Případné kešování herní úrovně pro případný opakovaný požadavek. 
\end{enumerate}


\subsection{Builder Dungeon Masteru -- \ccc{LegacyMapBuilder}}

Sestavení herní úrovně pro hru Dungeon Master zajišťuje třída \ccc{LegacyMapBuilder} z již připravených dat
v podobě třídy \ccc{DungeonData}. Tato třída používá ještě ke své funkci další buildery, které mohou mít
opět další -- celá jejich struktura viz obr. \ref{sub-builders}. Každý tento builder má běžně referenci
na \ccc{LegacyMapBuilder}, aby měl přístup k celému kontextu. Vlastnosti kontextu lze rozdělit na dvě skupiny:
\begin{itemize}
\item data, která se načítají pro každou herní úroveň znovu,
\item data, která jsou inicializovaná pouze při vytváření builderu. 
\end{itemize}

Do první skupiny patří následující důležité vlastnosti:
\begin{itemize}
\item \ccc{CurrentLevelIndex} -- určuje pořadí právě sestavované herní úrovně.
\item \ccc{CurrentMap} -- obsahuje data právě sestavované herní úrovně.
\item \ccc{TilePositions} -- kolekce, v které lze za pomocí pozice získat dlaždici, která ji náleží.
	Do této kolekce by se měly přidávat dlaždice s jejich pozicí při jejich vytváření.
	Kolekce je pak předána do výsledné herní úrovně reprezentované třídou \ccc{DungeonLevel}.

\item \ccc{TileInitializers} -- tato kolekce obsahuje inicializátory dlaždic, které by se měly 
	 do kolekce přidávat při vytváření odpovídajích dlaždic. Po vytvoření všech dlaždic je skrze tyto 
	 inicilizéry dokončena inicilizace dlaždic zavoláním funkce \ccc{InitializerBase.Initialize}.
\end{itemize}
Dále jsou pak v této skupině seznamy s texturami pro dveře, dekorace zdí, dekorace podlah a šampiony. Tyto seznamy mají prvky seřazeny tak, aby odpovídaly 
správným texturám při použití indexů dekorací specifikovaných v datech. Dále obsahuje ještě texturu pro 
dveře, zeď, tlačítko dveří a teleport.

V druhé část jsou pak obsaženy následující vlastnosti:
\begin{itemize}
\item \ccc{Data} -- veškerá data herních úrovní získané z parsovací vrstvy \vref{level-parsing} v objektu typu \ccc{DungeonData}.
\item \ccc{Factories} -- objekt obsahující všechny factories \vref{engine-core-section}.
\item \ccc{ItemCreator} -- objekt typu \ccc{IItemCreator} zajišťující vytváření sbíratelných předmětů z odpovídajících dat.
	Konkrétní implementaci je pak možné předat do konstruktoru při vytváření builderu.
\item \ccc{TileCreator} -- objekt \ccc{ITileCreator} zajišťující tvorbu dlaždic z odpovídajících dat.
	Konkrétní implementaci je pak možné předat do konstruktoru při vytváření builderu.
\item \ccc{CreatureToken} a \ccc{ChampionToken} -- tokeny šampionů a nepřátelských entit (viz. relace mezi entitami v sekci \ref{entities-relations}) 
\end{itemize}

Funkce \ccc{GetLevel} potom provede postup zmíněný v předchozí sekci (viz \ref{custom-builder}). Pro načtení dalších vlastních textur 
před sestavováním herní úrovně je možné přetížit funkce \ccc{InitializeMapTextures}. Pro získání factory dle globálního identifikátoru \vref{item-descriptors} 
existuje funkce \ccc{GetItemFactory}, která lze také případně přetížit. Pro získání již vytvořeného objektu dlaždice lze pak použít virtuální asynchronní funkci
\ccc{GetTargetTile}. Funkci je možné zavolat ještě když objekt pro dlaždici na dané pozici neexistuje. V tom případě se čeká na promise, která se naplní 
po vytvoření všech dlaždic. Funkce také řeší přesměrování pozice na dlaždici typu \xxx{zeď} na odpovídající dlaždici typu \xxx{podlaha} \vref{tile-representation}.

Buildery jsou ve jmenném prostoru \ccc{DungeonMasterEngine.Builders}.

\imgx{sub-builders}{Ilustrace struktury builderu.}

\subsubsection{Builder dlaždic -- \ccc{ILegacyTileCreator}}

Rozhraní \ccc{ILegacyTileCreator} má následující položky:
\begin{itemize}
\item \ccc{MiniMap} -- obsahuje texturu herní úrovně s dlaždicemi, které byly vytvořeny. 
\item \ccc{GetTile} -- tato funkce by měla z odpovídajících dat předaných v konstruktoru vytvořit dlaždici a její inicializátor přidat 
	do kolekce \ccc{LegacyMapBuilder.TileInitializers}. Dale by také měla zaznamenat dlaždici do minimapy.
\end{itemize}  
Implementací tohoto rozhraní je třída \ccc{LegacyTileCreator}, která dlaždice třídí pomocí návrhového vzoru visitor. Pro rozšíření
	této třídy je možné přetížit funkci \ccc{GetTile}. Tato třída pak ještě obsahuje buildery pro tvorby stěn dlaždice, nepřátel a logických přepínačů.
	Konkrétní implementace těchto tříd lze vložit do konstruktoru.


\subsubsection{Builder stran dlaždic -- \ccc{ISideCreator}}

Rozhraní \ccc{ISideCreator} obsahuje funkce \ccc{SetupSideAsync} a \ccc{SetupSideAwaitableAsync}, které vytvoří stěny dlaždic
a vloží je do předaného inicializátoru. Obě funkce dělají to samé, akorát druhou z nich je možné awaitovat. Konkrétní implementaci
tohoto rozhraní tvoří třída \ccc{SideCreator}, která obsahuje buildery pro vytvoření přepínačů na zdech a podlaze. Implementace
těchto buildrů lze opět specifikovat v konstruktoru. Rozšířením této třídy lze pak přetížit funkce \ccc{GetCeelingSide}, 
\ccc{GetWallSide} a \ccc{GetFloorSide}.


\subsubsection{Builder přepínačů na zdi -- \ccc{IWallActuatorCreator}}
Rozhraní \ccc{IWallActuatorCreator} vyžaduje funkci \ccc{ParseActuatorX}, která ze zadané sekvence dat senzorů a předmětů 
ve zdi vytvoří přepínač. Pro toto rozhraní existuje implementace \ccc{WallActuatorCreator}, u které lze při rozšíření
přetížit následující funkce:
\begin{itemize}
\item \ccc{ParseSensor} -- funkce dle typu senzoru v jeho datech, vytvoří senzor pro tento engine.
\item \ccc{CreateWallDecoration} -- funkce vytvoří dekoraci odpovídající přepínači \vref{general-sensors}.
\end{itemize}


\subsubsection{Builder přepínačů na podlaze -- \ccc{IFloorActuatorCreator}}
Rozhraní \ccc{IFloorActuatorCreator} definuje funkci \ccc{GetFloorActuator}, která ze zadané sekvence dat senzorů vytvoří přepínač. Třída \ccc{FloorActuatorCreator}
potom implementuje toto rozhraní a při jejím rozšíření lze přetížit funkci \ccc{CreateSensor}. Tato funkce vytvoří z dat o senzoru
senzor pro tento engine.

\subsubsection{Builder nepřátelský entit -- \ccc{ICreatureCreator}}
Toto rozhraní definuje jedinou funkci, a to \ccc{AddCreatureToTile}, která by měla rozparsovat data o skupině nepřátel a vytvořit z nich odpovídající entity.
Nepřátelské entity se potom zaregistrují na událost indikující dokončení inicializace všech dlaždic a obživnou na specifikované dlaždici.
Třída \ccc{CreatureCreator} implementuje toto rozhraní, kdy její funkce \ccc{AddCreatureToTile} lze přetížit.


\subsubsection{Builder logických přepínačů -- \ccc{ILogicActuatorCreator}}
Toto rozhraní implementuje třída \ccc{LogicActuatorCreator} a obsahuje funkci \ccc{SetLogicActuator}, která vytvoří logické senzory
a nastaví je do předaného inicializátoru. Přetížením funkce \ccc{LogicActuatorCreator.ParseLogicSensor} lze dodat podporu
pro další typy senzorů.


\subsubsection{Builder předmětů -- \ccc{ILegacyItemCreator}}
Tímto rozhraním lze za pomocí jeho funkce \ccc{CreateItem} vytvářet předměty na základě odpovídajících dat. Toto rozhraní implementuje třída
\ccc{LegacyItemCreator}, která vytváří předměty pomocí návrhového vzoru visitor. Přetížením její funkce \ccc{CreateItem} je možné přidat podporu
pro další předměty.


\section{Implemetace hráče -- \ccc{ILeader}}
Hráče reprezentuje rozhraní \ccc{ILeader}, které má následující položky:
\begin{itemize}
\item \ccc{LocationChanged} -- událost vyvolaná při změně dlaždice hráče. Jádro je na tuto událost zaregistrované a při jejím vyvolání provede aktualizaci
	viditelných dlaždic a pokus o načtení případných dalších úrovní \vref{engine-core-section}.
\item \ccc{PartyGroup} -- hráčova skupina obecných entit. Jádro tuto vlastnost používá k výpočtu osvětlení dle předmětů, které entita obsahuje.
\item \ccc{Hand} -- ruka hráče, do které se vloží předmět po kliknutí na něj nebo jinými akcemi.
\item \ccc{Interactor} -- objekt, který je používán k interakci s objekty. Používají ho renderery, které  musí vědět jakého typu je. Na tento typ ho pak musí přetypovat.
\item \ccc{Layout} -- určuje layout hráče na dlaždici.
\item \ccc{Leader} -- šampion, který je označený jako vůdce. Pomocí jeho statistik se pak určuje síla hodu předmětem.
\item \ccc{View} -- matice zobrazení.
\item \ccc{Projection} -- matice projekce.
\item \ccc{Enabled} -- určuje, zda má hráč reagovat na vstup z periferií -- při zobrazení konzole je například zablokován.
\item \ccc{AddChampoinToGroup} -- funkce pro přidání šampiona do skupiny.
\item \ccc{Draw} -- funkce, v které lze vykreslovat objekty.
\item \ccc{Update} -- funkce, která je volána v každém cyklu herní smyčky.
\end{itemize}

Implementaci hráče pro hru Dungeon Master tvoří třída \ccc{LegacyLeader} ve jmenném prostoru \ccc{DungeonMasterEngine.Player}. Jelikož v jádře se specifikuje typovým parametrem 
přímo typ hráč, je možné přistupovat z front endu i k položkám, které nejsou v rozhraní \ccc{ILeader}.




\section{Herní konzole -- \ccc{GameConsole}}\label{game-console}
Tato práce obsahuje vlastní implementaci konzole pro zadávání složitějších úkonů hráči.  
Konzole pak může vykonávat příkazy, které jsou reprezentovány rozhraním \ccc{IInterpreter}. Od konzole lze vytvořit
pouze jedna instance a to skrze statickou funkci \ccc{InitializeConsole}, které lze předat sadu
interpretrů příkazů.

\subsection{Interpreter -- \ccc{IInterpreter}}
Interpreter slouží ke komunikaci s hráčem skrze textový vstup a výstup. Na základě odpovědí od hráče provede příkaz, který reprezentuje.

Rozhraní \ccc{IInterpreter} má typový parametr určující kontext a obsahuje následující položky:
\begin{itemize}
\item \ccc{Input} -- \ccc{TextReader} obsahující vstupní stream typu \ccc{KeyboardStream} z klávesnice.
\item \ccc{Output} -- \ccc{TextWriter} obsahující výstupní stream typu \ccc{ScreenStream} do konzole.
\item \ccc{ConsoleContext} -- jakýkoliv kontext, jehož typ lze zvolit jako typový parametr.
\item \ccc{Parameters} -- pole textových parametrů, s kterým byl interpreter vytvořen.
\item \ccc{CanRunOnBackground} -- vlastnost určující, zda lze konzole minimalizovat v průběhu provádění tohoto interpretru.
\item \ccc{Run} -- asynchronní funkce obsahující algoritmus interpretru. 
\end{itemize}

Ke každému interpretru pak existuje factory, kterou definuje rozhraní \ccc{ICommandFactory} s následujícími položkami:
\begin{itemize}
\item \ccc{CommandToken} -- token, ke kterému náleží tato factory.
\item \ccc{HelpText} -- text reprezentující pomocnou zprávu, kterou můžou použít další příkazy. 
\item \ccc{ParameterParser} -- tokenizer parametrů definovaný rozhraním \ccc{IParameterParser}, které obsahuje jedinou funkci \ccc{ParseParameters}, 
	která rozdělí jednotlivé parametry do pole. Tvůrce interpretru by měl tento tokenizer použít pro získání pole parametrů, které 
	následně předá interpretru.
\item \ccc{GetNewInterpreter} -- vytvoří novou instanci interpretru.
\end{itemize}

Je zodpovědností tvůrce interpretru, aby mu nastavil vlastnosti \ccc{Input}, \ccc{Output}, \ccc{ConsoleContext}, \ccc{Parameters}
a vyvolal funkci \ccc{Run}. Tato funkce je asynchronní, takže je možné čekat na její dokončení bez blokování vlákna. Pro
čtení vstupu je pak nutné používat asynchronní funkci. Ke čtení \ccc{KeyboarStreamu} se potom používá \ccc{KeyboardStreamReader},
která dokáže číst vstup čistě asynchronně bez nutnosti použití dalších vláken.

 Jednotlivé příkazy lze najít ve jmenném prostoru:\newline \ccc{DungeonMasterEngine.GameConsoleContent}.

\subsection{Implementace konzole}
Konzole má pak interpreter typu \ccc{BaseInterpreter} implmentující rozhraní \ccc{IInterpreter}. Tomuto interpreteru
jsou při jeho vytvoření předány všechny factories interpretrů, které podporuje. Ve funkci \ccc{Run} potom
obsahuje nekonečnou smyčku, jež čte vstup, dle kterého se pokusí najít factory odpovídajícího interpretru. Pomocí
factory pak vytvoří daný interpreter, nastaví mu všechny vlastnosti zmiňované v předchozí sekci a předá mu kontrolu
zavoláním funkce \ccc{Run}. Kromě tohoto způsobu ještě umožňuje vyvolat daný interpreter, který je mu předán 
do funkce \ccc{RunCommand}.

Následující kód pak ukazuje smyčku \ccc{BaseInterpreteru} jako další příklad užití asynchronních funkcí v enginu.

\begin{code}
async Task Run()
{
   Output.WriteLine("Welcome!"); 

   while (Running)
   {
      RunningCommand = await GetInterpreter();

      if (RunningCommand != null)
      {
         RunningCommand.Input = Input;
         RunningCommand.Output = Output;
         RunningCommand.ConsoleContext = ConsoleContext;

         await RunningCommand.Run();
         RunningCommand = null;
         Output.WriteLine();
      }
      else
      {
         Output.WriteLine("Unrecognized command!");
      }
   }

   Output.WriteLine("Have a nice day.");
}
\end{code}

Jako kontext potom interpreter konzole používá \ccc{IConsoleContext}, který definuje kolekci použitých interpretrů a referenci na jádro enginu.


\section{Neimplementované funkce enginu}\label{not-implemented}

Tato sekce obsahuje převážně seznamy neimplementovaných funkcí enginu pro hru Dungeon Master. Pokud je určitá množina funkcí jasně stanovena,
jsou u ní uvedeny i implementované funkce.

\subsection{Akce}
Seznam všech akcí může být nalezen v komunitní dokumentaci \cite{TechnicalDocumentationFontanel05} nebo 
v dekompilovaných zdrojových kódech \cite{DMDecompilation} v souboru \ccc{DEFS.H} na řádku 1467.

\begin{itemize}

\item Třída \ccc{SwingAttackFactory} implementuje následující akce: BASH, HACK, BERZERK, KICK, SWING a CHOP. 

\item Třída \ccc{MeleeAttackFactory} implementuje následující akce: DISRUPT, JAB, PARRY, STAB, STAB, STUN, THRUST, MELEE, SLASH, CLEAVE a PUNCH.
V této třídě chybí podpora pro útok proti nemateriálním nepřátelským entitám. Také chybí reakce na obtížnost herních úrovní, kterou lze získat
skrze vlastnost \ccc{DungeonMap.Difficult}. Implementace výběru nepřátelského cíle se také drobně liší od originálu.
            
\item Třída \ccc{ThrowActionFactory} implementuje akci THROW. 

\item Následující akce enginu nejsou implementovány: BLOCK, BLOW\_HORN, FLIP, WAR\_CRY, CLIMB\_DOWN, FREEZE\_LIFE, HIT, FIREBALL, DISPELL,
CONFUSE, LIGHTNING, INVOKE, SHOOT, SPELLSHIELD, FIRESHIELD, FLUXCAGE, HEAL, CALM, LIGHT, WINDOW, SPIT, BRANDISH a FUSE.
Pro případné doimplementované akce je nutné zaregistrovat jejich factories ve funkci \ccc{LegacyFactories.GetFightActionsFactories}.

\end{itemize}

\subsection{Přepínače}
Seznam všech typů přepínačů může být nalezen v komunitní technické dokumentaci \cite{TechnicalDocumentationFontanel05}  nebo 
v dekompilovaných zdrojových kódech \cite{DMDecompilation} v souboru \ccc{DEFS.H} na řádku 1467.

\begin{itemize}
\item Implementované senzory:
	\begin{itemize}
	\item Senzory na zdech -- 1, 2, 3, 4, 5, 6, 11, 12, 13, 16, 17 a 127.  
	\item Senzory na podlaze -- 1, 2, 3, 4, 6, 7 a 8. 
	\end{itemize}

\item Neimplementované senzory:
	\begin{itemize}
	\item Senzory na zdech:
		\begin{itemize}
		\item 7, 8, 9, 10, 14 a 15 -- senzory střílející rakety.
		\item 18 -- senzor pro konec hry.
		\end{itemize}
		Případné dodělané senzory na zeď je nutné přidat do funkce \ccc{WallActuatorCreator.ParseSensor}.
	\item Senzory na podlaze:
		\begin{itemize}
		\item 5 -- senzor, který může být pouze na schodech -- do verze 2.1 originální hry je nefunkční,
		\item 6 -- generátor nepřátelských entit,
		\item 9 -- version checker. 
		\end{itemize}
		Případné dodělané senzory na podlahu je nutné přidat do funkce \ccc{FloorActuatorCreator.CreateSensor}.
	\end{itemize}
\end{itemize}


\subsection{Nepřátelské entity}

\begin{itemize}
\item Chybí implementace rozhraní \ccc{IGroupLayout} pro entity obsazující polovinu prostoru dlaždice.
\item Nepřátelské entity se neotáčejí a vidí všemi směry. Nicméně při pohybu by měly vidět pouze před sebe a při změně pohybu by se měly otáčet.
\item Chybí speciální implementace pro některé nepřátelské entity. Například nepřátelská entita \ccc{Black Flame} by se neměla pohybovat a ohnivé
    útoky by ji měly posilovat. Dalším příkladem je entita \ccc{Giggler}, která v originální hře může šampionům krást věci z rukou. Kompletní seznam
	těchto speciálních funkcí  není znám, nicméně lze je nalézt různě roztroušené ve zdrojových kódech \cite{DMDecompilation}.
\item Chybí implementace útoků na dálku pro určité nepřátelské entity. Kód vykonávající útoky je ve funkci \ccc{F207\_xxxx\_GROUP\_IsCreatureAttacking} 
	v dekompilovaných zdrojových kódech hry \cite{DMDecompilation}. Implementace útoku na blízko je ve třídě \ccc{CreatureAttack}.

\item V originální hře lze nepřátelské entity některými útoky vyděsit tak, že před hráčem utíkají -- tato funkce opět není implementována.
\item Pozůstatky po nepřátelských entitách definované v souboru \ccc{GRAPHICS.DAT} nejsou implementované. Nějaké informace 
je možné nalézt v dokumentaci nepřátelský entit \cite{DMCreatures} nebo v dokumentaci pro část souboru \ccc{GRAPHICS.DAT} \cite{DMGraphicsDAT} viz ,,Creature droppings definitions".
\item Útok nepřátelských entity by měl mít vyšší účinnost, když skupina odpočívá (viz třída \ccc{CreatureAttack}).

\end{itemize}
Pro nové implementace nepřátelský entity je třeba vytvořit jejich factories a zaregistrovat je ve funkci \ccc{LegacyFactories.InitCreatureFactories}


\subsection{Předměty}
Některé předměty mohou modifikovat nositelovy vlastnosti. Implementace této funkce u předmětů chybí. Jak který předmět modifikuje 
vlastnosti svého nositele lze buď nalézt různě roztroušené ve dekompilovaných zdrojových kódech \cite{DMDecompilation}, nebo v komunitní dokumentaci pro předměty \cite{DMItems}.
Nicméně u vlastností je k tomuto účelu připravena kolekce \ccc{IProperty.AdditionalValues}, do které by se tyto modifikátory zaregistrovaly při oblečení předmětu.

Některé předměty by také mělo jít prohodit skrze dveře, jejich seznam je pevně stanoven v kódu hry \cite{DMDecompilation} ve funkci \ccc{F217\_xxxx\_PROJECTILE\_HasImpactOccured} 

\subsection{Kouzla}

Následuje seznam implementovaných kouzel:
\begin{itemize}
\item Třída \ccc{ExplosionProjectileSpellFactory} implementuje následující vzdálená útočná kouzla: fire ball, weaken nonmaterial beings,
	poison bolt,  poison cloud,  lightning bolt. Některá z těchto kouzel mohou vyvolávat i nepřátelé, a tak tyto kouzla mohou zranit jak šampiony tak 
	nepřátelské entity. V originální hře jsou pro výpočet výsledného zranění používány následující dvě funkce:
	\begin{itemize}
	\item \ccc{F190\_zzzz\_GROUP\_GetDamageCreatureOutcome} -- provádí výpočet zranění pro nepřátelské entity,
	\item \ccc{F321\_AA29\_CHAMPION\_AddPendingDamageAndWounds\_GetDamage} -- provádí výpočet zranění pro šampiony, navíc oproti předchozí funkci určuje, zda 
	útok zranil nějakou část těla šampiona.
	\end{itemize}
	Zde nastává problém s tím, že jsme pro šampiony i nepřátele použili stejnou abstrakci entit. Proto, aby implementace zranění byla stejná jako v originální hře,
	by útočná kouzla musela zjišťovat konkrétní typ entity. To by ale vedlo na nepřehledný a hlavně špatně rozšiřitelný kód. Z toho důvodu jsme
	se rozhodli v tomto případě použít pro výpočet zranění pouze funkci určenou pro nepřátelské entity. Nicméně lepším řešením by bylo detailně porozumět
	kódu obou funkcí a na jejich základě vytvořit jednotnou variantu, která by rozdíly mezi entitami řešila pomocí jejich vlastností.

\item Třída \ccc{PotionSpellFactory} implementuje následující kouzla vytvářející lektvary: poison potion, dexterity potion, strength potion, wisdom potion,
	vitality potion, cure poison potion, stamina potion, shield potion, mana potion a health potion.

\item Kouzlo torch je implementované třídou \ccc{MagicTorchSpellFactory}.
\item Kouzlo open door je implementované třídou \ccc{OpenDoorSpellFactory}.
\end{itemize}

Následuje seznam neimplementovaných kouzel: fire shield, shield, darkness, light, magic footprints,
see through walls, invisibility, zokathra spell,

Kouzla ovlivňující vlastnosti jako magická pochodeň, magický štít, štít proti ohni nebo štít ovlivňují každého šampiona
zvlášť, oproti originálu, kde jsou to vlastnosti skupiny.

Factories doimplementovaných kouzel je nutné přidat ve funkci \ccc{LegacySpellCreator.GetSpell}.
               

\subsection{Další neimplementované nebo pozměněné funkce}
\begin{itemize}
\item Šampiony nelze ve skupině rozmisťovat -- funkcionalita lze doimplementovat do třídy \ccc{LegacyLeader}.
\item Aktualizace vlastností šampionů v originální hře je ovlivněna kritériem, závislým na způsobu počítání času v originální hře.
	Význam tohoto kritéria se nepodařilo rozluštit a je místo něj použita náhodná hodnota v rozsahu hodnot, které kritérium 
	nabývá v původní hře viz \newline \ccc{Champion.F331\_auzz\_CHAMPION\_ApplyTimeEffects\_COPYPROTECTIONF}.
\item Nejsou známy hodnoty pro převod ,,light power" na "light amount" použité pro výpočet osvětlení. Hodnoty 
jsou zvoleny tak, aby přibližně odpovídaly hodnotám při hraní originální hry, viz funkce \ccc{DungeonBase.UpdateLight}
\newline resp. \ccc{F337\_akzz\_INVENTORY\_SetDungeonViewPalette}.
\end{itemize}